{
  parserClass="com.github.daym.ideasqlplugin.language.parser.SqlParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Sql"
  psiImplClassSuffix="Impl"
  psiPackage="com.github.daym.ideasqlplugin.language.psi"
  psiImplPackage="com.github.daym.ideasqlplugin.language.psi.impl"

  elementTypeHolderClass="com.github.daym.ideasqlplugin.language.psi.SqlTypes"
  elementTypeClass="com.github.daym.ideasqlplugin.language.psi.SqlElementType"
  tokenTypeClass="com.github.daym.ideasqlplugin.language.psi.SqlTokenType"
  tokens=[
    space='regexp:\s+'
    white_space='regexp:\s+'
    bracketed_comment_introducer='regexp:/[*]'
    bracketed_comment_terminator='regexp:[*]/'
    // TODO: More detail (see LEX)
    identifier_body='regexp:\p{Alpha}\w*'
    // TODO: More detail
    nonquote_character='regexp:[a-zA-Z _-]+'
    // FIXME
    newline='\n'
    // TODO: comment='regexp:--.*'
    // TODO: string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"
    // TODO: number='regexp:\d+(\.\d*)?'

    // TODO: op_1 = '+'
    // TODO: op_2 = '-'
    // TODO: op_3 = '*'
    // TODO: op_4 = '/'
    // TODO: op_5 = '!'
  ]
}

root ::= directly_executable_statement  'GO' *

SQL_object_identifier ::= SQL_provenance SQL_variant

SQL_provenance ::= arc1 arc2 arc3

arc1 ::= 'iso' | '1' | 'iso' left_paren '1' right_paren

arc2 ::= standard | '0' | standard left_paren '0' right_paren

arc3 ::= '9075'

SQL_variant ::= SQL_edition SQL_conformance

SQL_edition ::= J1987 | J1989 | J1992 | J1999

J1987 ::= '0' | 'edition1987' left_paren '0' right_paren

J1989 ::= J1989_base J1989_package

J1989_base ::= '1' | 'edition1989' left_paren 1 right_paren

J1989_package ::= integrity_no | integrity_yes

integrity_no ::= '0' | 'IntegrityNo' left_paren 0 right_paren

integrity_yes ::= '1' | 'IntegrityYes' left_paren 1 right_paren

J1992 ::= '2' | 'edition1992' left_paren '2' right_paren

J1999 ::= '3' | 'edition1999' left_paren '3' right_paren

SQL_conformance ::= level parts // 'FIXME' packages

level ::= low | intermediate | high

low ::= '0' | 'Low' left_paren '0' right_paren

intermediate ::= '1' | 'Intermediate' left_paren '1' right_paren

high ::= '2' | 'High' left_paren '2' right_paren

parts ::= // 'FIXME' Part_3 Part_4 Part_5 Part_6 Part_7 Part_8 Part_9 Part_10

//p
//small
//i
/*The parenthesized (i) and (n) are italic in the  'SQL' standard.
It is not clear exactly what this should look like, despite all the
information.
However, it is also not important; this is not really a part of the  'SQL'
language per se.
Note that the package numbers are PKG001 to PKG009, for example.
We still have to devise a mechanism to persuade bnf2yacc.pl to ignore
this information.
*/
///i
///small
///p
// Dropped: PKG(i)

/*
packages ::= Package_PKG_i_ *

Part_n ::= Part_n_no | Part_n_yes

Part_n_no ::= '0' | 'Part-(n)No' left_paren 0 right_paren

Part_n_yes ::= //!! (as specified in ISO/IEC 9075-(n))

Package_PKG_i_ ::= Package_PKG_i_Yes | Package_PKG_i_No

Part_3_yes ::= Part_3_conformance

Part_3_conformance ::= '3' | 'sqlcli1999' left_paren '3' right_paren

Part_4_yes ::= Part_4_conformance Part_4_module

Part_4_conformance ::= '4' | 'sqlpsm1999' left_paren '4' right_paren

Part_4_module ::= Part_4_module_yes | Part_4_module_no

Part_4_module_yes ::= '1' | moduleyes left_paren '1' right_paren

Part_4_module_no ::= '0' | moduleno left_paren '0' right_paren

Part_5_yes ::= Part_5_conformance Part_5_direct Part_5_embedded
*/

//p
//small
//i
//The original used sqlbindings199x, but the x should clearly be a 9.
///i
///small
///p

Part_5_conformance ::= '5' | 'sqlbindings1999' left_paren '5' right_paren

Part_5_direct ::= Part_5_direct_yes | Part_5_direct_no

Part_5_direct_yes ::= '1' | 'directyes' left_paren '1' right_paren

Part_5_direct_no ::= '0' | 'directno' left_paren '0' right_paren

Part_5_embedded ::= Part_5_embedded_no | Part_5_embedded_languages *

Part_5_embedded_no ::= '0' | embeddedno left_paren '0' right_paren

Part_5_embedded_languages ::=
		Part_5_embedded_Ada
	|	Part_5_embedded_C
	|	Part_5_embedded_COBOL
	|	Part_5_embedded_Fortran
	|	Part_5_embedded_MUMPS
	|	Part_5_embedded_Pascal
	|	Part_5_embedded_PL_I

Part_5_embedded_Ada ::= '1' | embeddedAda left_paren '1' right_paren

Part_5_embedded_C ::= '2' | embeddedC left_paren '2' right_paren

Part_5_embedded_COBOL ::= '3' | embeddedCOBOL left_paren '3' right_paren

Part_5_embedded_Fortran ::= '4' | embeddedFortran left_paren '4' right_paren

Part_5_embedded_MUMPS ::= '5' | embeddedMUMPS left_paren '5' right_paren

Part_5_embedded_Pascal ::= '6' | embeddedPascal left_paren '6' right_paren

Part_5_embedded_PL_I ::= '7' | embeddedPLI left_paren '7' right_paren

//hr
//h2 Basic Definitions of Characters Used, Tokens, Symbols, Etc.
///h2

//p
//Most of this section would normally be handled within the lexical
//analyzer rather than in the grammar proper.
//Further, the original document does not quote the various single
//characters, which makes it hard to process automatically.
///p

SQL_terminal_character ::= SQL_language_character

SQL_language_character ::= simple_Latin_letter | digit | SQL_special_character

simple_Latin_letter ::=
		simple_Latin_upper_case_letter
	|	simple_Latin_lower_case_letter

simple_Latin_upper_case_letter ::=
		'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z'

simple_Latin_lower_case_letter ::=
		'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z'

digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

SQL_special_character ::=
		space
	|	double_quote
	|	percent
	|	ampersand
	|	quote
	|	left_paren
	|	right_paren
	|	asterisk
	|	plus_sign
	|	comma
	|	minus_sign
	|	period
	|	solidus
	|	colon
	|	semicolon
	|	less_than_operator
	|	equals_operator
	|	greater_than_operator
	|	question_mark
	|	left_bracket
	|	right_bracket
	|	circumflex
	|	underscore
	|	vertical_bar
	|	left_brace
	|	right_brace

double_quote ::= '"'
percent ::= '%'
ampersand ::= '&'
quote ::= "'"
left_paren ::= '('
right_paren ::= ')'
asterisk ::= '*'
plus_sign ::= '+'
comma ::= ','
minus_sign ::= '-'
period ::= '.'
solidus ::= '/'
colon ::= ':'
semicolon ::= ';'
less_than_operator ::= '<'
equals_operator ::= '='
greater_than_operator ::= '>'
question_mark ::= '?'
left_bracket ::= '['
right_bracket ::= ']'
circumflex ::= '^'
underscore ::= '_'
vertical_bar ::= '|'
left_brace ::= '{'
right_brace ::= '}'

//hr
//h2 Literal Numbers, Strings, Dates and Times
///h2

//p
//small
//i SQL-client_module_definition modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

SQL-client_module_definition ::=
		module_name_clause
		language_clause
		module_authorization_clause
		[ module_path_specification ]
		[ module_transform_group_specification ]
		[ temporary_table_declaration * ]
		module_contents *

module_name_clause ::=
	 	'MODULE' [ SQL-client_module_name ] [ module_character_set_specification ]

SQL-client_module_name ::= identifier

identifier ::= actual_identifier

actual_identifier ::= regular_identifier | delimited_identifier

regular_identifier ::= identifier_body

//p
//small
//i identifier_body modified per  'ISO' 9075:1999/Cor.1:2000(E).
///i
///p
//p
//i identifier_body also rationalized by removing curly brackets
//around identifier_part because they are unnecessary and inconsistent
//with other places where '*' modifies a single non-terminal.
///i
///small
///small
///p

module_character_set_specification ::= 'NAMES' 'ARE' character_set_specification

character_set_specification ::=
		standard_character_set_name
	|	implementation-defined_character_set_name
	|	user-defined_character_set_name

standard_character_set_name ::= character_set_name

character_set_name ::= [ schema_name period ] SQL_language_identifier

schema_name ::= [ catalog_name period ] unqualified_schema_name

catalog_name ::= identifier

unqualified_schema_name ::= identifier

SQL_language_identifier ::=
		SQL_language_identifier_start [ { underscore | SQL_language_identifier_part }* ]

SQL_language_identifier_start ::= simple_Latin_letter

SQL_language_identifier_part ::= simple_Latin_letter | digit

implementation-defined_character_set_name ::= character_set_name

user-defined_character_set_name ::= character_set_name

language_clause ::=  'LANGUAGE' language_name

language_name ::=  'ADA' | C |  'COBOL' |  'FORTRAN' |  'MUMPS' |  'PASCAL' |  'PLI' |  'SQL'

//@@ This module authorization clause is superceded by a variant from 9075-5 SQL/Bindings.

//@@ module_authorization_clause ::=
//@@ 	 	'SCHEMA' schema_name
//@@ 	| 	'AUTHORIZATION' module_authorization_identifier
//@@ 	| 	'SCHEMA' schema_name  'AUTHORIZATION' module_authorization_identifier

module_authorization_identifier ::= authorization_identifier

authorization_identifier ::= role_name | user_identifier

role_name ::= identifier

user_identifier ::= identifier

module_path_specification ::= path_specification

path_specification ::=  'PATH' schema_name_list

schema_name_list ::= schema_name [ { comma schema_name }* ]

module_transform_group_specification ::= transform_group_specification

transform_group_specification ::=
	 	'TRANSFORM'  'GROUP' { single_group_specification | multiple_group_specification }

single_group_specification ::= group_name

group_name ::= identifier

multiple_group_specification ::= group_specification [ { comma group_specification }* ]

group_specification ::= group_name  'FOR' 'TYPE' user-defined_type

user-defined_type ::= user-defined_type_name

user-defined_type_name ::= schema_qualified_type_name

schema_qualified_type_name ::= [ schema_name period ] qualified_identifier

qualified_identifier ::= identifier

temporary_table_declaration ::=
	 	'DECLARE'  'LOCAL' 'TEMPORARY'  'TABLE' table_name
		table_element_list
		[  'ON' 'COMMIT' table_commit_action  'ROWS' ]

table_name ::= local_or_schema_qualified_name

local_or_schema_qualified_name ::= [ local_or_schema_qualifier period ] qualified_identifier

local_or_schema_qualifier ::= schema_name |  'MODULE'

table_element_list ::=
		left_paren table_element [ { comma table_element }* ] right_paren

table_element ::=
		column_definition
	|	table_constraint_definition
	|	like_clause
	|	self-referencing_column_specification
	|	column_options

column_definition ::=
		column_name
		{ data_type | domain_name }
		[ reference_scope_check ]
		[ default_clause ]
		[ column_constraint_definition * ]
		[ collate_clause ]

column_name ::= identifier

//hr
//h2 Data Types
///h2

simple_data_type ::=
		predefined_type
	|	row_type
	|	user-defined_type
	|	reference_type

data_type ::=
		simple_data_type
    |	collection_type // FIXME

predefined_type ::=
		character_string_type [  'CHARACTER' 'SET' character_set_specification ]
	|	national_character_string_type
	|	binary_large_object_string_type
	|	bit_string_type
	|	numeric_type
	|	boolean_type
	|	datetime_type
	|	interval_type

character_string_type ::=
	 	'CHARACTER' [ left_paren length right_paren ]
	| 	'CHAR' [ left_paren length right_paren ]
	| 	'CHARACTER'  'VARYING' left_paren length right_paren
	| 	'CHAR'  'VARYING' left_paren length right_paren
	| 	'VARCHAR' left_paren length right_paren
	| 	'CHARACTER'  'LARGE' 'OBJECT' [ left_paren large_object_length right_paren ]
	| 	'CHAR'  'LARGE' 'OBJECT' [ left_paren large_object_length right_paren ]
	| 	'CLOB' [ left_paren large_object_length right_paren ]

length ::= unsigned_integer

unsigned_integer ::= digit digit*

large_object_length ::= unsigned_integer [ multiplier ] | large_object_length_token

multiplier ::= 'K' | 'M' | 'G'

large_object_length_token ::= digit digit* multiplier

national_character_string_type ::=
	 	'NATIONAL'  'CHARACTER' [ left_paren length right_paren ]
	| 	'NATIONAL'  'CHAR' [ left_paren length right_paren ]
	| 	'NCHAR' [ left_paren length right_paren ]
	| 	'NATIONAL'  'CHARACTER' 'VARYING' left_paren length right_paren
	| 	'NATIONAL'  'CHAR' 'VARYING' left_paren length right_paren
	| 	'NCHAR'  'VARYING' left_paren length right_paren
	| 	'NATIONAL'  'CHARACTER' 'LARGE'  'OBJECT' [ left_paren large_object_length right_paren ]
	| 	'NCHAR'  'LARGE' 'OBJECT' [ left_paren large_object_length right_paren ]
	| 	'NCLOB' [ left_paren large_object_length right_paren ]

binary_large_object_string_type ::=
	 	'BINARY'  'LARGE' 'OBJECT' [ left_paren large_object_length right_paren ]
	| 	'BLOB' [ left_paren large_object_length right_paren ]

bit_string_type ::=
	 	'BIT' [ left_paren length right_paren ]
	| 	'BIT'  'VARYING' left_paren length right_paren

numeric_type ::= exact_numeric_type | approximate_numeric_type

exact_numeric_type ::=
	 	'NUMERIC' [ left_paren precision [ comma scale ] right_paren ]
	| 	'DECIMAL' [ left_paren precision [ comma scale ] right_paren ]
	| 	'DEC' [ left_paren precision [ comma scale ] right_paren ]
	| 	'INTEGER'
	| 	'INT'
	| 	'SMALLINT'

precision ::= unsigned_integer

scale ::= unsigned_integer

approximate_numeric_type ::=
	 	'FLOAT' [ left_paren precision right_paren ]
	| 	'REAL'
	| 	'DOUBLE'  'PRECISION'

boolean_type ::=  'BOOLEAN'

datetime_type ::=
	 	'DATE'
	| 	'TIME' [ left_paren time_precision right_paren ] [ with_or_without_time_zone ]
	| 	'TIMESTAMP' [ left_paren timestamp_precision right_paren ] [ with_or_without_time_zone ]

time_precision ::= time_fractional_seconds_precision

time_fractional_seconds_precision ::= unsigned_integer

with_or_without_time_zone ::=  'WITH' 'TIME'  'ZONE' |  'WITHOUT' 'TIME'  'ZONE'

timestamp_precision ::= time_fractional_seconds_precision

interval_type ::=  'INTERVAL' interval_qualifier

interval_qualifier ::= start_field  'TO' end_field | single_datetime_field

start_field ::=
		non-second_primary_datetime_field [ left_paren interval_leading_field_precision right_paren ]

non-second_primary_datetime_field ::=  'YEAR' |  'MONTH' |  'DAY' |  'HOUR' |  'MINUTE'

interval_leading_field_precision ::= unsigned_integer

end_field ::=
		non-second_primary_datetime_field
	| 	'SECOND' [ left_paren interval_fractional_seconds_precision right_paren ]

interval_fractional_seconds_precision ::= unsigned_integer

single_datetime_field ::=
		non-second_primary_datetime_field [ left_paren interval_leading_field_precision right_paren ]
	| 	'SECOND' [ left_paren interval_leading_field_precision [ comma interval_fractional_seconds_precision ] right_paren ]

row_type ::=  'ROW' row_type_body

row_type_body ::= left_paren field_definition [ { comma field_definition }* ] right_paren

field_definition ::= field_name data_type [ reference_scope_check ] [ collate_clause ]

field_name ::= identifier

reference_scope_check ::=
	 	'REFERENCES'  'ARE' [  'NOT' ]  'CHECKED' [  'ON' 'DELETE' reference_scope_check_action ]

reference_scope_check_action ::= referential_action

referential_action ::=
	 	'CASCADE'
	| 	'SET'  'NULL'
	| 	'SET'  'DEFAULT'
	| 	'RESTRICT'
	| 	'NO'  'ACTION'

collate_clause ::=  'COLLATE' collation_name

collation_name ::= schema_qualified_name

schema_qualified_name ::= [ schema_name period ] qualified_identifier

reference_type ::=  'REF' left_paren referenced_type right_paren [ scope_clause ]

referenced_type ::= user-defined_type

scope_clause ::=  'SCOPE' table_name

// FIXME the collection now doesn't support foo(2)(3), which it does in the standard.
collection_type ::= simple_data_type array_specification

array_specification ::=
		collection_type_constructor left_bracket_or_trigraph unsigned_integer right_bracket_or_trigraph

collection_type_constructor ::=  'ARRAY'

left_bracket_or_trigraph ::= left_bracket | left_bracket_trigraph

//p
//small
//i
//The trigraphs are strictly sequences of characters, not sequences of tokens.
//There may not be any spaces between the characters.
//Normally, the lexical analyzer would return the trigraphs as a simple symbol.
///i
///small
///p

left_bracket_trigraph ::= question_mark question_mark left_paren

right_bracket_or_trigraph ::= right_bracket | right_bracket_trigraph

right_bracket_trigraph ::= question_mark question_mark right_paren

domain_name ::= schema_qualified_name

default_clause ::=  'DEFAULT' default_option

default_option ::=
		literal
	|	datetime_value_function
	| 	'USER'
	| 	'CURRENT_USER'
	| 	'CURRENT_ROLE'
	| 	'SESSION_USER'
	| 	'SYSTEM_USER'
	| 	'CURRENT_PATH'
	|	implicitly_typed_value_specification

//hr
//h2 Literals
///h2

literal ::= signed_numeric_literal | general_literal

signed_numeric_literal ::= [ sign ] unsigned_numeric_literal

sign ::= plus_sign | minus_sign

unsigned_numeric_literal ::= exact_numeric_literal | approximate_numeric_literal

exact_numeric_literal ::=
		unsigned_integer [ period [ unsigned_integer ] ]
	|	period unsigned_integer

approximate_numeric_literal ::= mantissa E exponent

mantissa ::= exact_numeric_literal

exponent ::= signed_integer

signed_integer ::= [ sign ] unsigned_integer

general_literal ::=
		character_string_literal
	|	national_character_string_literal
	|	bit_string_literal
	|	hex_string_literal
	|	binary_string_literal
	|	datetime_literal
	|	interval_literal
	|	boolean_literal

character_string_literal ::=
		[ introducer character_set_specification ]
		quote [ character_representation* ] quote
		[ { separator quote [ character_representation* ] quote }* ]

introducer ::= underscore

character_representation ::= nonquote_character | quote_symbol

//p
//small
//i
//The quote_symbol rule consists of two immediately adjacent quote
//marks with no spaces.
//As usual, this would be best handled in the lexical analyzer, not in the
//grammar.
///i
///small
///p

quote_symbol ::= quotequote

separator ::= { comment | white_space }*

comment ::= simple_comment | bracketed_comment

simple_comment ::= simple_comment_introducer [ comment_character* ] newline

simple_comment_introducer ::= minus_sign minus_sign [ minus_sign* ]

comment_character ::= nonquote_character | quote

//p
//small
//i
//The bracketed_comment rule included '!! (See the Syntax Rules)'.
//This probably says something about the slash asterisk and asterisk
//slash needing to be adjacent characters rather than adjacent tokens.
///i
///small
///p

bracketed_comment ::=
		bracketed_comment_introducer bracketed_comment_contents bracketed_comment_terminator

bracketed_comment_contents ::= [ { comment_character | separator }* ]

national_character_string_literal ::=
		N quote [ character_representation* ] quote
		[ { separator quote [ character_representation* ] quote }* ]

bit_string_literal ::=
		B quote [ bit* ] quote
		[ { separator quote [ bit* ] quote }* ]

bit ::= '0' | '1'

hex_string_literal ::=
		X quote [ hexit* ] quote
		[ { separator quote [ hexit* ] quote }* ]

hexit ::= digit | A | B | C | D | E | F | a | b | c | d | e | f

binary_string_literal ::=
		X quote [ { hexit hexit }* ] quote
		[ { separator quote [ { hexit hexit }* ] quote }* ]

datetime_literal ::= date_literal | time_literal | timestamp_literal

date_literal ::=  'DATE' date_string

date_string ::= quote unquoted_date_string quote

unquoted_date_string ::= date_value

date_value ::= years_value minus_sign months_value minus_sign days_value

years_value ::= datetime_value

datetime_value ::= unsigned_integer

months_value ::= datetime_value

days_value ::= datetime_value

time_literal ::=  'TIME' time_string

time_string ::= quote unquoted_time_string quote

unquoted_time_string ::= time_value [ time_zone_interval ]

time_value ::= hours_value colon minutes_value colon seconds_value

hours_value ::= datetime_value

minutes_value ::= datetime_value

seconds_value ::= seconds_integer_value [ period [ seconds_fraction ] ]

seconds_integer_value ::= unsigned_integer

seconds_fraction ::= unsigned_integer

time_zone_interval ::= sign hours_value colon minutes_value

timestamp_literal ::=  'TIMESTAMP' timestamp_string

timestamp_string ::= quote unquoted_timestamp_string quote

unquoted_timestamp_string ::= unquoted_date_string space unquoted_time_string

interval_literal ::=  'INTERVAL' [ sign ] interval_string interval_qualifier

interval_string ::= quote unquoted_interval_string quote

unquoted_interval_string ::= [ sign ] { year-month_literal | day-time_literal }

year-month_literal ::= years_value | [ years_value minus_sign ] months_value

day-time_literal ::= day-time_interval | time_interval

day-time_interval ::=
		days_value [ space hours_value [ colon minutes_value [ colon seconds_value ] ] ]

time_interval ::=
		hours_value [ colon minutes_value [ colon seconds_value ] ]
	|	minutes_value [ colon seconds_value ]
	|	seconds_value

boolean_literal ::=  'TRUE' |  'FALSE' |  'UNKNOWN'

datetime_value_function ::=
		current_date_value_function
	|	current_time_value_function
	|	current_timestamp_value_function
	|	current_local_time_value_function
	|	current_local_timestamp_value_function

current_date_value_function ::=  'CURRENT_DATE'

current_time_value_function ::=
	 	'CURRENT_TIME' [ left_paren time_precision right_paren ]

current_timestamp_value_function ::=
	 	'CURRENT_TIMESTAMP' [ left_paren timestamp_precision right_paren ]

current_local_time_value_function ::=
	 	'LOCALTIME' [ left_paren time_precision right_paren ]

current_local_timestamp_value_function ::=
	 	'LOCALTIMESTAMP' [ left_paren timestamp_precision right_paren ]

implicitly_typed_value_specification ::= null_specification | empty_specification

null_specification ::=  'NULL'

empty_specification ::=  'ARRAY' left_bracket_or_trigraph right_bracket_or_trigraph

//hr
//h2 Constraints
///h2

column_constraint_definition ::=
		[ constraint_name_definition ] column_constraint [ constraint_characteristics ]

constraint_name_definition ::=  'CONSTRAINT' constraint_name

constraint_name ::= schema_qualified_name

column_constraint ::=
	 	'NOT'  'NULL'
	|	unique_specification
	|	references_specification
	|	check_constraint_definition

unique_specification ::=  'UNIQUE' |  'PRIMARY'  'KEY'

references_specification ::=
	 	'REFERENCES' referenced_table_and_columns
		[  'MATCH' match_type ] [ referential_triggered_action ]

referenced_table_and_columns ::=
		table_name [ left_paren reference_column_list right_paren ]

reference_column_list ::= column_name_list

column_name_list ::= column_name [ { comma column_name }* ]

match_type ::=  'FULL' |  'PARTIAL' |  'SIMPLE'

referential_triggered_action ::=
		update_rule [ delete_rule ]
	|	delete_rule [ update_rule ]

update_rule ::=  'ON' 'UPDATE' referential_action

delete_rule ::=  'ON' 'DELETE' referential_action

check_constraint_definition ::=  'CHECK' left_paren search_condition right_paren

//hr
//h2 Search Condition
///h2

search_condition ::= boolean_value_expression

boolean_value_expression ::=
		boolean_term
	|  boolean_term 'OR' boolean_value_expression

boolean_term ::=
		boolean_factor
	|	boolean_factor 'AND' boolean_term

boolean_factor ::= [  'NOT' ] boolean_test

boolean_test ::= boolean_primary [  'IS' [  'NOT' ] truth_value ]

boolean_primary ::=
		predicate
	|	parenthesized_boolean_value_expression
	|	nonparenthesized_value_expression_primary

predicate ::=
		comparison_predicate
	|	between_predicate
	|	in_predicate
	|	like_predicate
	|	null_predicate
	|	quantified_comparison_predicate
	|	exists_predicate
	|	unique_predicate
	|	match_predicate
	|	overlaps_predicate
	|	similar_predicate
	|	distinct_predicate
	|	type_predicate

comparison_predicate ::= row_value_expression comp_op row_value_expression

row_value_expression ::= row_value_special_case | row_value_constructor

row_value_special_case ::= value_specification | value_expression

value_specification ::= literal | general_value_specification

general_value_specification ::=
		host_parameter_specification
	|	SQL_parameter_reference
	|	SQL_variable_reference
	|	dynamic_parameter_specification
	|	embedded_variable_specification
	| 	'CURRENT_DEFAULT_TRANSFORM_GROUP'
	| 	'CURRENT_PATH'
	| 	'CURRENT_ROLE'
	| 	'CURRENT_TRANSFORM_GROUP_FOR_TYPE' user-defined_type
	| 	'CURRENT_USER'
	| 	'SESSION_USER'
	| 	'SYSTEM_USER'
	| 	'USER'
	| 	'VALUE'

host_parameter_specification ::= host_parameter_name [ indicator_parameter ]

host_parameter_name ::= colon identifier

indicator_parameter ::= [  'INDICATOR' ] host_parameter_name

SQL_parameter_reference ::= basic_identifier_chain

basic_identifier_chain ::= identifier_chain

identifier_chain ::= identifier [ { period identifier }* ]

value_expression ::=
		numeric_value_expression
	|	string_value_expression
	|	datetime_value_expression
	|	interval_value_expression
// FIXME	|	boolean_value_expression
	|	user-defined_type_value_expression
// FIXME	|	row_value_expression
	|	reference_value_expression
	|	collection_value_expression

numeric_value_expression ::=
		term
	|	term plus_sign numeric_value_expression
	|	term minus_sign numeric_value_expression

term ::=
		factor
	|	factor asterisk term
	|	factor solidus term

factor ::= [ sign ] numeric_primary

numeric_primary ::=
		value_expression_primary
	|	numeric_value_function

value_expression_primary ::=
		parenthesized_value_expression
	|	nonparenthesized_value_expression_primary

parenthesized_value_expression ::= left_paren value_expression right_paren

nonparenthesized_value_expression_primary ::=
		unsigned_value_specification
	|	column_reference
	|	set_function_specification
	|	scalar_subquery
	|	case_expression
	|	cast_specification
	|	subtype_treatment
//	|	attribute_or_method_reference // FIXME
//	|	reference_resolution // FIXME
//	|	collection_value_constructor // FIXME
	|	routine_invocation // FIXME
//	|	field_reference // FIXME
//	|	element_reference // FIXME
//	|	method_invocation // FIXME
	|	static_method_invocation
	|	new_specification

unsigned_value_specification ::= unsigned_literal | general_value_specification

unsigned_literal ::= unsigned_numeric_literal | general_literal

column_reference ::=
		basic_identifier_chain
	| 	'MODULE' period qualified_identifier period column_name

set_function_specification ::=
	 	'COUNT' left_paren asterisk right_paren
	|	general_set_function
	|	grouping_operation

general_set_function ::=
		set_function_type left_paren [ set_quantifier ] value_expression right_paren

set_function_type ::= computational_operation

computational_operation ::=  'AVG' |  'MAX' |  'MIN' |  'SUM' |  'EVERY' |  'ANY' |  'SOME' |  'COUNT'

set_quantifier ::=  'DISTINCT' |  'ALL'

grouping_operation ::=  'GROUPING' left_paren column_reference right_paren

//hr
//h2 Queries
///h2

scalar_subquery ::= subquery

subquery ::= left_paren query_expression right_paren

query_expression ::= [ with_clause ] query_expression_body

with_clause ::=  'WITH' [  'RECURSIVE' ] with_list

with_list ::= with_list_element [ { comma with_list_element }* ]

with_list_element ::=
		query_name
		[ left_paren with_column_list right_paren ]
	 	'AS' left_paren query_expression right_paren
		[ search_or_cycle_clause ]

query_name ::= identifier

with_column_list ::= column_name_list

search_or_cycle_clause ::=
		search_clause
	|	cycle_clause
	|	search_clause cycle_clause

search_clause ::=
	 	'SEARCH' recursive_search_order  'SET' sequence_column

recursive_search_order ::=
	 	'DEPTH'  'FIRST' 'BY' sort_specification_list
	| 	'BREADTH'  'FIRST' 'BY' sort_specification_list

sort_specification_list ::= sort_specification [ { comma sort_specification }* ]

//p
//small
//i sort_specification modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

sort_specification ::= sort_key [ ordering_specification ]

sort_key ::= value_expression

ordering_specification ::=  'ASC' |  'DESC'

sequence_column ::= column_name

cycle_clause ::=
	 	'CYCLE' cycle_column_list
	 	'SET' cycle_mark_column  'TO' cycle_mark_value
	 	'DEFAULT' non-cycle_mark_value
	 	'USING' path_column

cycle_column_list ::= cycle_column [ { comma cycle_column }* ]

cycle_column ::= column_name

cycle_mark_column ::= column_name

cycle_mark_value ::= value_expression

non-cycle_mark_value ::= value_expression

path_column ::= column_name

query_expression_body ::= non-join_query_expression | joined_table

non-join_query_expression ::=
		non-join_query_term
	|	query_expression_body  'UNION'  [  'ALL' |  'DISTINCT' ] [ corresponding_spec ] query_term
	|	query_expression_body  'EXCEPT' [  'ALL' |  'DISTINCT' ] [ corresponding_spec ] query_term

non-join_query_term ::=
		non-join_query_primary
	|	query_term  'INTERSECT' [  'ALL' |  'DISTINCT' ] [ corresponding_spec ] query_primary

non-join_query_primary ::=
		simple_table
	|	left_paren non-join_query_expression right_paren

simple_table ::= query_specification | table_value_constructor | explicit_table

query_specification ::=  'SELECT' [ set_quantifier ] select_list table_expression

select_list ::= asterisk | select_sublist [ { comma select_sublist }* ]

select_sublist ::= derived_column | qualified_asterisk

derived_column ::= value_expression [ as_clause ]

as_clause ::= [  'AS' ] column_name

qualified_asterisk ::=
		asterisked_identifier_chain period asterisk
	|	all_fields_reference

asterisked_identifier_chain ::= asterisked_identifier [ { period asterisked_identifier }* ]

asterisked_identifier ::= identifier

all_fields_reference ::= value_expression_primary period asterisk

table_expression ::= from_clause [ where_clause ] [ group_by_clause ] [ having_clause ]

from_clause ::=  'FROM' table_reference_list

table_reference_list ::= table_reference [ { comma table_reference }* ]

table_reference ::= table_primary | joined_table

table_primary ::=
		table_or_query_name [ [  'AS' ] correlation_name [ left_paren derived_column_list right_paren ] ]
	|	derived_table [  'AS' ] correlation_name [ left_paren derived_column_list right_paren ]
	|	lateral_derived_table [  'AS' ] correlation_name [ left_paren derived_column_list right_paren ]
	|	collection_derived_table [  'AS' ] correlation_name [ left_paren derived_column_list right_paren ]
	|	only_spec [ [  'AS' ] correlation_name [ left_paren derived_column_list right_paren ] ]
	|	left_paren joined_table right_paren

table_or_query_name ::= table_name | query_name

correlation_name ::= identifier

derived_column_list ::= column_name_list

derived_table ::= table_subquery

table_subquery ::= subquery

lateral_derived_table ::=  'LATERAL' left_paren query_expression right_paren

collection_derived_table ::=
	 	'UNNEST' left_paren collection_value_expression right_paren [  'WITH' 'ORDINALITY' ]

collection_value_expression ::= value_expression_primary

only_spec ::=  'ONLY' left_paren table_or_query_name right_paren

joined_table ::= cross_join | qualified_join | natural_join | union_join

cross_join ::= table_reference  'CROSS' 'JOIN' table_primary

qualified_join ::= table_reference [ join_type ]  'JOIN' table_reference join_specification

join_type ::=  'INNER' | outer_join_type [  'OUTER' ]

outer_join_type ::=  'LEFT' |  'RIGHT' |  'FULL'

join_specification ::= join_condition | named_columns_join

join_condition ::=  'ON' search_condition

named_columns_join ::=  'USING' left_paren join_column_list right_paren

join_column_list ::= column_name_list

natural_join ::= table_reference  'NATURAL' [ join_type ]  'JOIN' table_primary

union_join ::= table_reference  'UNION' 'JOIN' table_primary

where_clause ::=  'WHERE' search_condition

//p
//small
//i Rules from group_by_clause to grouping_set modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

group_by_clause ::=  'GROUP' 'BY' grouping_element_list

grouping_element_list ::= grouping_element [ { comma grouping_element }* ]

grouping_element ::=
		ordinary_grouping_set
	|	rollup_list
	|	cube_list
	|	grouping_sets_specification
	|	grand_total

grouping_column_reference ::= column_reference [ collate_clause ]

rollup_list ::=  'ROLLUP' left_paren grouping_column_reference_list right_paren

grouping_column_reference_list ::=
		grouping_column_reference [ { comma grouping_column_reference }* ]

cube_list ::=  'CUBE' left_paren grouping_column_reference_list right_paren

grouping_sets_specification ::=  'GROUPING' 'SETS' left_paren grouping_set_list right_paren

grouping_set_list ::= grouping_set [ { comma grouping_set }* ]

grouping_set ::=
		ordinary_grouping_set
	|	rollup_list
	|	cube_list
	|	grouping_sets_specification
	|	grand_total

ordinary_grouping_set ::=
		grouping_column_reference
	|	left_paren grouping_column_reference_list right_paren

grand_total ::= left_paren right_paren

concatenated_grouping ::= grouping_set comma grouping_set_list

having_clause ::=  'HAVING' search_condition

table_value_constructor ::=  'VALUES' row_value_expression_list

row_value_expression_list ::= row_value_expression [ { comma row_value_expression }* ]

explicit_table ::=  'TABLE' table_name

//hr
//h2 Query expression components
///h2

query_term ::= non-join_query_term | joined_table

corresponding_spec ::=
	 	'CORRESPONDING' [  'BY' left_paren corresponding_column_list right_paren ]

corresponding_column_list ::= column_name_list

query_primary ::= non-join_query_primary | joined_table

case_expression ::= case_abbreviation | case_specification

case_abbreviation ::=
	 	'NULLIF' left_paren value_expression comma value_expression right_paren
	| 	'COALESCE' left_paren value_expression { comma value_expression }* right_paren

case_specification ::= simple_case | searched_case

simple_case ::=  'CASE' case_operand simple_when_clause* [ else_clause ]  'END'

case_operand ::= value_expression

simple_when_clause ::=  'WHEN' when_operand  'THEN' result

when_operand ::= value_expression

result ::= result_expression |  'NULL'

result_expression ::= value_expression

else_clause ::=  'ELSE' result

searched_case ::=  'CASE' searched_when_clause* [ else_clause ]  'END'

searched_when_clause ::=  'WHEN' search_condition  'THEN' result

cast_specification ::=  'CAST' left_paren cast_operand  'AS' cast_target right_paren

cast_operand ::= value_expression | implicitly_typed_value_specification

cast_target ::= domain_name | data_type

//p
//small
//i subtype_treatment to target_subtype modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

subtype_treatment ::=
	 	'TREAT' left_paren subtype_operand  'AS' target_subtype right_paren

subtype_operand ::= value_expression

target_subtype ::= user-defined_type

attribute_or_method_reference ::=
		value_expression_primary dereference_operator qualified_identifier
		[ SQL_argument_list ]

dereference_operator ::= right_arrow

right_arrow ::= '->'

SQL_argument_list ::=
		left_paren [ SQL_argument [ { comma SQL_argument }* ] ] right_paren

SQL_argument ::= value_expression | generalized_expression | target_specification

generalized_expression ::= value_expression  'AS' user-defined_type

target_specification ::=
		host_parameter_specification
	|	SQL_parameter_reference
	|	column_reference
	|	SQL_variable_reference
	|	dynamic_parameter_specification
	|	embedded_variable_specification

reference_resolution ::=  'DEREF' left_paren reference_value_expression right_paren

reference_value_expression ::= value_expression_primary

collection_value_constructor ::= array_value_expression

array_value_expression ::= array_value_constructor
  | array_concatenation
  | value_expression_primary

array_value_constructor ::= array_value_list_constructor

array_value_list_constructor ::=
	 	'ARRAY' left_bracket_or_trigraph array_element_list right_bracket_or_trigraph

array_element_list ::= array_element [ { comma array_element }* ]

array_element ::= value_expression

array_concatenation ::=
		array_value_expression concatenation_operator array_value_expression

concatenation_operator ::= '||' // FIXME

routine_invocation ::= routine_name SQL_argument_list

routine_name ::= [ schema_name period ] qualified_identifier

field_reference ::= value_expression_primary period field_name

element_reference ::=
		array_value_expression left_bracket_or_trigraph numeric_value_expression right_bracket_or_trigraph

method_invocation ::= direct_invocation | generalized_invocation

direct_invocation ::=
		value_expression_primary period method_name [ SQL_argument_list ]

method_name ::= identifier

generalized_invocation ::=
		left_paren value_expression_primary
	 	'AS' data_type right_paren period method_name
		[ SQL_argument_list ]

//p
//small
//i It is not remotely clear why this was needed in this grammar.
///i
//i constructor_method_selection added per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

constructor_method_selection ::= routine_invocation

static_method_invocation ::=
		user-defined_type double_colon method_name [ SQL_argument_list ]

//p
//small
//i
//Note that double_colon must be a pair of characters with no
//intervening space, not a pair of colon symbols separated by arbitrary
//white space.
//Normally, the lexical analyzer would return double_colon as a symbol.
///i
///small
///p

double_colon ::= colon colon

new_specification ::=  'NEW' routine_invocation

numeric_value_function ::=
		position_expression
	|	extract_expression
	|	length_expression
	|	cardinality_expression
	|	absolute_value_expression
	|	modulus_expression

position_expression ::= string_position_expression | blob_position_expression

string_position_expression ::=
	 	'POSITION' left_paren string_value_expression  'IN' string_value_expression right_paren

string_value_expression ::= character_value_expression | bit_value_expression | blob_value_expression

character_value_expression ::= concatenation | character_factor

concatenation ::= character_factor concatenation_operator character_value_expression

character_factor ::= character_primary [ collate_clause ]

character_primary ::= value_expression_primary | string_value_function

string_value_function ::= character_value_function | blob_value_function | bit_value_function

character_value_function ::=
		character_substring_function
	|	regular_expression_substring_function
	|	fold
	|	form-of-use_conversion
	|	character_translation
	|	trim_function
	|	character_overlay_function
	|	specific_type_method

character_substring_function ::=
	 	'SUBSTRING' left_paren character_value_expression  'FROM' start_position
		[  'FOR' string_length ] right_paren

start_position ::= numeric_value_expression

string_length ::= numeric_value_expression

//p
//small
//i regular_expression_substring_function modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

regular_expression_substring_function ::=
	 	'SUBSTRING' left_paren character_value_expression  'SIMILAR'
		character_value_expression  'ESCAPE' escape_character right_paren

escape_character ::= character_value_expression

fold ::= {  'UPPER' |  'LOWER' } left_paren character_value_expression right_paren

form-of-use_conversion ::=
	 	'CONVERT' left_paren character_value_expression
	 	'USING' form-of-use_conversion_name right_paren

form-of-use_conversion_name ::= schema_qualified_name

character_translation ::=
	 	'TRANSLATE' left_paren character_value_expression
	 	'USING' translation_name right_paren

translation_name ::= schema_qualified_name

trim_function ::=  'TRIM' left_paren trim_operands right_paren

trim_operands ::= [ [ trim_specification ] [ trim_character ]  'FROM' ] trim_source

trim_specification ::=  'LEADING' |  'TRAILING' |  'BOTH'

trim_character ::= character_value_expression

trim_source ::= character_value_expression

character_overlay_function ::=
	 	'OVERLAY' left_paren character_value_expression  'PLACING' character_value_expression
	 	'FROM' start_position [  'FOR' string_length ] right_paren

specific_type_method ::= user-defined_type_value_expression period  'SPECIFICTYPE'

user-defined_type_value_expression ::= value_expression_primary

blob_value_function ::= blob_substring_function | blob_trim_function | blob_overlay_function

blob_substring_function ::=
	 	'SUBSTRING' left_paren blob_value_expression  'FROM' start_position
		[  'FOR' string_length ] right_paren

blob_value_expression ::= blob_concatenation | blob_factor

blob_concatenation ::= blob_factor concatenation_operator blob_value_expression

blob_factor ::= blob_primary

blob_primary ::= value_expression_primary | string_value_function

blob_trim_function ::=  'TRIM' left_paren blob_trim_operands right_paren

blob_trim_operands ::= [ [ trim_specification ] [ trim_octet ]  'FROM' ] blob_trim_source

trim_octet ::= blob_value_expression

blob_trim_source ::= blob_value_expression

blob_overlay_function ::=
	 	'OVERLAY' left_paren blob_value_expression  'PLACING' blob_value_expression
	 	'FROM' start_position [  'FOR' string_length ] right_paren

bit_value_function ::= bit_substring_function

bit_substring_function ::=
	 	'SUBSTRING' left_paren bit_value_expression  'FROM' start_position
		[  'FOR' string_length ] right_paren

bit_value_expression ::= bit_concatenation | bit_factor

bit_concatenation ::= bit_factor concatenation_operator bit_value_expression

bit_factor ::= bit_primary

bit_primary ::= value_expression_primary | string_value_function

blob_position_expression ::=
	 	'POSITION' left_paren blob_value_expression  'IN' blob_value_expression right_paren

extract_expression ::=
	 	'EXTRACT' left_paren extract_field  'FROM' extract_source right_paren

extract_field ::= primary_datetime_field | time_zone_field

primary_datetime_field ::= non-second_primary_datetime_field |  'SECOND'

time_zone_field ::=  'TIMEZONE_HOUR' |  'TIMEZONE_MINUTE'

extract_source ::= datetime_value_expression | interval_value_expression

datetime_value_expression ::=
		datetime_term
	|	interval_value_expression plus_sign datetime_term
	|	datetime_value_expression plus_sign interval_term
	|	datetime_value_expression minus_sign interval_term

interval_term ::=
		interval_factor
	|	factor asterisk interval_term
	|	factor solidus interval_term
	|	interval_factor asterisk term // FIXME check

interval_factor ::= [ sign ] interval_primary

//@@ This definition of interval primary is superceded by the version from 9075-5 SQL/Bindings
//@@ interval_primary ::= value_expression_primary | interval_value_function

interval_value_function ::= interval_absolute_value_function

interval_absolute_value_function ::=  'ABS' left_paren interval_value_expression right_paren

interval_value_expression ::=
		interval_term
	|	interval_term plus_sign interval_value_expression
	|	interval_term minus_sign interval_value_expression
	|	left_paren datetime_value_expression minus_sign
		datetime_term right_paren interval_qualifier

datetime_term ::= datetime_factor

datetime_factor ::= datetime_primary [ time_zone ]

datetime_primary ::= value_expression_primary | datetime_value_function

time_zone ::=  'AT' time_zone_specifier

time_zone_specifier ::=  'LOCAL' |  'TIME' 'ZONE' interval_primary

length_expression ::= char_length_expression | octet_length_expression | bit_length_expression

char_length_expression ::=
		{  'CHAR_LENGTH' |  'CHARACTER_LENGTH' } left_paren string_value_expression right_paren

octet_length_expression ::=
	 	'OCTET_LENGTH' left_paren string_value_expression right_paren

bit_length_expression ::=
	 	'BIT_LENGTH' left_paren string_value_expression right_paren

cardinality_expression ::=
	 	'CARDINALITY' left_paren collection_value_expression right_paren

absolute_value_expression ::=
	 	'ABS' left_paren numeric_value_expression right_paren

modulus_expression ::=
	 	'MOD' left_paren numeric_value_expression_dividend comma numeric_value_expression_divisorright_paren

numeric_value_expression_dividend ::= numeric_value_expression

numeric_value_expression_divisor ::= numeric_value_expression

row_value_constructor ::=
		row_value_constructor_element
	|	[  'ROW' ] left_paren row_value_constructor_element_list right_paren
	|	row_subquery

row_value_constructor_element ::= value_expression

row_value_constructor_element_list ::=
		row_value_constructor_element [ { comma row_value_constructor_element }* ]

row_subquery ::= subquery

comp_op ::=
		equals_operator
	|	not_equals_operator
	|	less_than_operator
	|	greater_than_operator
	|	less_than_or_equals_operator
	|	greater_than_or_equals_operator

//p
//small
//i
/*The not_equals, less_than_or_equals_operator and greater_than_or_equals operator
should be handled by the lexical analyzer as token
symbols, not by the grammar.
As usual, spaces are not allowed between the two characters.*/
///i
///small
///p

not_equals_operator ::= less_than_operator greater_than_operator

less_than_or_equals_operator ::= less_than_operator equals_operator

greater_than_or_equals_operator ::= greater_than_operator equals_operator

between_predicate ::=
		row_value_expression [  'NOT' ]  'BETWEEN' [  'ASYMMETRIC' |  'SYMMETRIC' ]
		row_value_expression  'AND' row_value_expression

in_predicate ::= row_value_expression [  'NOT' ]  'IN' in_predicate_value

in_predicate_value ::= table_subquery | left_paren in_value_list right_paren

//p
//small
//i Previously, the expression in curly braces was not in square brackets.
///i
//i Consequently, every in_value_list had to have at least two items in it.
///i
///small
///p

in_value_list ::= row_value_expression [ { comma row_value_expression }* ]

like_predicate ::= character_like_predicate | octet_like_predicate

character_like_predicate ::=
		character_match_value [  'NOT' ]  'LIKE' character_pattern [  'ESCAPE' escape_character ]

character_match_value ::= character_value_expression

character_pattern ::= character_value_expression

octet_like_predicate ::=
		octet_match_value [  'NOT' ]  'LIKE' octet_pattern [  'ESCAPE' escape_octet ]

octet_match_value ::= blob_value_expression

octet_pattern ::= blob_value_expression

escape_octet ::= blob_value_expression

null_predicate ::= row_value_expression  'IS' [  'NOT' ]  'NULL'

quantified_comparison_predicate ::= row_value_expression comp_op quantifier table_subquery

quantifier ::= all | some

all ::=  'ALL'

some ::=  'SOME' |  'ANY'

exists_predicate ::=  'EXISTS' table_subquery

unique_predicate ::=  'UNIQUE' table_subquery

match_predicate ::=
		row_value_expression  'MATCH' [  'UNIQUE' ] [  'SIMPLE' |  'PARTIAL' |  'FULL' ]
		table_subquery

overlaps_predicate ::= row_value_expression_1  'OVERLAPS' row_value_expression_2

row_value_expression_1 ::= row_value_expression

row_value_expression_2 ::= row_value_expression

similar_predicate ::=
		character_match_value [  'NOT' ]  'SIMILAR' 'TO' similar_pattern [  'ESCAPE' escape_character ]

similar_pattern ::= character_value_expression

//hr
//h2 Regular Expressions for  'SIMILAR'  'TO'
///h2

//p
//These regular expressions are not referenced anywhere else in the
//document, but define the structure that the character_value_expression
//used in similar_pattern must have.
//Structurally, these regular expressions are similar to 'egrep'
//expressions, except they use underscore in place of dot, and percent is
//equivalent to dot star in 'egrep'.
//The other omission is the use of caret (aka circumflex) to mark the
//start of the matched text and dollar to mark the end of the matched
//text.
///p

//regular_expression ::=
//		regular_term
//	|	regular_expression vertical_bar regular_term
//
//regular_term ::=
//		regular_factor
//	|	regular_term regular_factor
//
//regular_factor ::=
//		regular_primary
//	|	regular_primary asterisk
//	|	regular_primary plus_sign
//
//regular_primary ::=
//		character_specifier
//	|	percent
//	|	regular_character_set
//	|	left_paren regular_expression right_paren
//
//character_specifier ::= non-escaped_character | escaped_character
//
//non-escaped_character ::= !! (See the Syntax Rules)
//
//escaped_character ::= !! (See the Syntax Rules)
//
//regular_character_set ::=
//		underscore
//	|	left_bracket character_enumeration* right_bracket
//	|	left_bracket circumflex character_enumeration* right_bracket
//	|	left_bracket colon regular_character_set_identifier colon right_bracket
//
//character_enumeration ::=
//		character_specifier
//	|	character_specifier minus_sign character_specifier
//
//regular_character_set_identifier ::= identifier

//hr

distinct_predicate ::=
		row_value_expression_3  'IS' 'DISTINCT'  'FROM' row_value_expression_4

row_value_expression_3 ::= row_value_expression

row_value_expression_4 ::= row_value_expression

type_predicate ::=
		user-defined_type_value_expression  'IS' [  'NOT' ]  'OF' left_paren type_list right_paren

type_list ::=
		user-defined_type_specification [ { comma user-defined_type_specification }* ]

user-defined_type_specification ::=
		inclusive_user-defined_type_specification
	|	exclusive_user-defined_type_specification

inclusive_user-defined_type_specification ::= user-defined_type

exclusive_user-defined_type_specification ::=  'ONLY' user-defined_type

parenthesized_boolean_value_expression ::= left_paren boolean_value_expression right_paren

truth_value ::=  'TRUE' |  'FALSE' |  'UNKNOWN'

//hr
//h2 More about constraints
///h2

constraint_characteristics ::=
		constraint_check_time [ [  'NOT' ]  'DEFERRABLE' ]
	|	[  'NOT' ]  'DEFERRABLE' [ constraint_check_time ]

constraint_check_time ::=  'INITIALLY' 'DEFERRED' |  'INITIALLY'  'IMMEDIATE'

table_constraint_definition ::=
		[ constraint_name_definition ] table_constraint [ constraint_characteristics ]

table_constraint ::= unique_constraint_definition | referential_constraint_definition | check_constraint_definition

//p
//small
//i
//The standard documents  'UNIQUE' (  'VALUE' ) but there is no explanation of
//why that is different from the  'UNIQUE' left_paren  'VALUE' right_paren
//used here.
///i
///small
///p

unique_constraint_definition ::=
		unique_specification left_paren unique_column_list right_paren
	| 	'UNIQUE' left_paren  'VALUE' right_paren

unique_column_list ::= column_name_list

referential_constraint_definition ::=
	 	'FOREIGN'  'KEY' left_paren referencing_columns right_paren references_specification

referencing_columns ::= reference_column_list

like_clause ::=  'LIKE' table_name

self-referencing_column_specification ::=
	 	'REF'  'IS' self-referencing_column_name reference_generation

self-referencing_column_name ::= column_name

reference_generation ::=  'SYSTEM' 'GENERATED' |  'USER' 'GENERATED' |  'DERIVED'

column_options ::= column_name  'WITH' 'OPTIONS' column_option_list

column_option_list ::=
		[ scope_clause ] [ default_clause ] [ column_constraint_definition* ] [ collate_clause ]

table_commit_action ::=  'PRESERVE' |  'DELETE'

//hr
//h2 Module contents
///h2

module_contents ::=
		declare_cursor
	|	externally-invoked_procedure
	|	dynamic_declare_cursor

declare_cursor ::=
	 	'DECLARE' cursor_name [ cursor_sensitivity ] [ cursor_scrollability ]  'CURSOR'
		[ cursor_holdability ] [ cursor_returnability ]  'FOR' cursor_specification

cursor_name ::= local_qualified_name

local_qualified_name ::= [ local_qualifier period ] qualified_identifier

local_qualifier ::=  'MODULE'

cursor_sensitivity ::=  'SENSITIVE' |  'INSENSITIVE' |  'ASENSITIVE'

cursor_scrollability ::=  'SCROLL' |  'NO'  'SCROLL'

cursor_holdability ::=  'WITH' 'HOLD' |  'WITHOUT'  'HOLD'

cursor_returnability ::=  'WITH' 'RETURN' |  'WITHOUT'  'RETURN'

cursor_specification ::= query_expression [ order_by_clause ] [ updatability_clause ]

order_by_clause ::=  'ORDER' 'BY' sort_specification_list

updatability_clause ::=  'FOR' {  'READ' 'ONLY' |  'UPDATE' [  'OF' column_name_list ] }

//hr
//h2  'SQL' Procedures
///h2

externally-invoked_procedure ::=
	 	'PROCEDURE' procedure_name
		host_parameter_declaration_setup semicolon
		SQL_procedure_statement semicolon

procedure_name ::= identifier

//p
//small
//i host_parameter_declaration_setup modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

host_parameter_declaration_setup ::= host_parameter_declaration_list

host_parameter_declaration_list ::=
		left_paren host_parameter_declaration
		[ { comma host_parameter_declaration }* ] right_paren

host_parameter_declaration ::=
		host_parameter_name host_parameter_data_type
	|	status_parameter

host_parameter_data_type ::= data_type [ locator_indication ]

locator_indication ::=  'AS'  'LOCATOR'

status_parameter ::=  'SQLSTATE'

SQL_procedure_statement ::= SQL_executable_statement

SQL_executable_statement ::=
		SQL_schema_statement
	|	SQL_data_statement
	|	SQL_control_statement
	|	SQL_transaction_statement
	|	SQL_connection_statement
	|	SQL_session_statement
	|	SQL_diagnostics_statement
	|	SQL_dynamic_statement

//hr
//h2  'SQL' Schema Definition Statements
///h2

SQL_schema_statement ::=
		SQL_schema_definition_statement
	|	SQL_schema_manipulation_statement

//p
//small
//i SQL_schema_definition_statement modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

SQL_schema_definition_statement ::=
		schema_definition
	|	table_definition
	|	view_definition
	|	SQL-invoked_routine
	|	grant_statement
	|	role_definition
	|	domain_definition
	|	character_set_definition
	|	collation_definition
	|	translation_definition
	|	assertion_definition
	|	trigger_definition
	|	user-defined_type_definition
	|	user-defined_cast_definition
	|	user-defined_ordering_definition
	|	transform_definition
	|	SQL-server_module_definition

schema_definition ::=
	 	'CREATE'  'SCHEMA' schema_name_clause [ schema_character_set_or_path ]
		[ schema_element* ]

schema_name_clause ::=
		schema_name
	| 	'AUTHORIZATION' schema_authorization_identifier
	|	schema_name  'AUTHORIZATION' schema_authorization_identifier

schema_authorization_identifier ::= authorization_identifier

schema_character_set_or_path ::=
		schema_character_set_specification
	|	schema_path_specification
	|	schema_character_set_specification schema_path_specification
	|	schema_path_specification schema_character_set_specification

schema_character_set_specification ::=
	 	'DEFAULT'  'CHARACTER' 'SET' character_set_specification

schema_path_specification ::= path_specification

//p
//small
//i schema_element modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

schema_element ::=
		table_definition
	|	view_definition
	|	domain_definition
	|	character_set_definition
	|	collation_definition
	|	translation_definition
	|	assertion_definition
	|	trigger_definition
	|	user-defined_type_definition
	|	schema_routine
	|	grant_statement
	|	role_definition
	|	user-defined_cast_definition
	|	user-defined_ordering_definition
	|	transform_definition

table_definition ::=
	 	'CREATE' [ table_scope ]  'TABLE' table_name table_contents_source
		[  'ON' 'COMMIT' table_commit_action  'ROWS' ]

table_scope ::= global_or_local  'TEMPORARY'

global_or_local ::=  'GLOBAL' |  'LOCAL'

table_contents_source ::=
		table_element_list
	| 	'OF' user-defined_type [ subtable_clause ] [ table_element_list ]

subtable_clause ::=  'UNDER' supertable_clause

supertable_clause ::= supertable_name

supertable_name ::= table_name

view_definition ::=
	 	'CREATE' [  'RECURSIVE' ]  'VIEW' table_name view_specification
	 	'AS' query_expression [  'WITH' [ levels_clause ]  'CHECK' 'OPTION' ]

view_specification ::= regular_view_specification | referenceable_view_specification

regular_view_specification ::= [ left_paren view_column_list right_paren ]

view_column_list ::= column_name_list

referenceable_view_specification ::=  'OF' user-defined_type [ subview_clause ] [ view_element_list ]

subview_clause ::=  'UNDER' table_name

view_element_list ::=
		left_paren [ self-referencing_column_specification comma ]
		view_element [ { comma view_element }* ] right_paren

view_element ::= view_column_option

view_column_option ::= column_name  'WITH' 'OPTIONS' scope_clause

levels_clause ::=  'CASCADED' |  'LOCAL'

domain_definition ::=
	 	'CREATE'  'DOMAIN' domain_name [  'AS' ] data_type
		[ default_clause ] [ domain_constraint* ] [ collate_clause ]

domain_constraint ::=
		[ constraint_name_definition ] check_constraint_definition [ constraint_characteristics ]

character_set_definition ::=
	 	'CREATE'  'CHARACTER' 'SET' character_set_name
		[  'AS' ] character_set_source [ collate_clause ]

character_set_source ::=  'GET' character_set_specification

collation_definition ::=
	 	'CREATE'  'COLLATION' collation_name  'FOR' character_set_specification
	 	'FROM' existing_collation_name [ pad_characteristic ]

existing_collation_name ::= collation_name

pad_characteristic ::=  'NO' 'PAD' |  'PAD'  'SPACE'

translation_definition ::=
	 	'CREATE'  'TRANSLATION' translation_name  'FOR' source_character_set_specification
	 	'TO' target_character_set_specification  'FROM' translation_source

source_character_set_specification ::= character_set_specification

target_character_set_specification ::= character_set_specification

translation_source ::= existing_translation_name | translation_routine

existing_translation_name ::= translation_name

translation_routine ::= specific_routine_designator

//p
//small
//i specific_routine_designator modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

specific_routine_designator ::=
	 	'SPECIFIC' routine_type specific_name
	|	routine_type member_name [  'FOR' user-defined_type_name ]

//p
//small
//i specific_routine_designator modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

routine_type ::=
	 	'ROUTINE' |  'FUNCTION' |  'PROCEDURE'
	|	[  'INSTANCE' |  'STATIC' |  'CONSTRUCTOR' ]  'METHOD'

specific_name ::= schema_qualified_name

member_name ::= schema_qualified_routine_name [ data_type_list ]

schema_qualified_routine_name ::= schema_qualified_name

data_type_list ::=
		left_paren [ data_type [ { comma data_type }* ] ] right_paren

assertion_definition ::=
	 	'CREATE'  'ASSERTION' constraint_name
	 	'CHECK' left_paren search_condition right_paren [ constraint_characteristics ]

trigger_definition ::=
	 	'CREATE'  'TRIGGER' trigger_name trigger_action_time trigger_event
	 	'ON' table_name [  'REFERENCING' old_or_new_values_alias_list ] triggered_action

trigger_name ::= schema_qualified_name

trigger_action_time ::=  'BEFORE' |  'AFTER'

trigger_event ::=  'INSERT' |  'DELETE' |  'UPDATE' [  'OF' trigger_column_list ]

trigger_column_list ::= column_name_list

old_or_new_values_alias_list ::= old_or_new_values_alias*

old_or_new_values_alias ::=
	 	'OLD' [  'ROW' ] [  'AS' ] old_values_correlation_name
	| 	'NEW' [  'ROW' ] [  'AS' ] new_values_correlation_name
	| 	'OLD'  'TABLE' [  'AS' ] old_values_table_alias
	| 	'NEW'  'TABLE' [  'AS' ] new_values_table_alias

old_values_correlation_name ::= correlation_name

new_values_correlation_name ::= correlation_name

old_values_table_alias ::= identifier

new_values_table_alias ::= identifier

triggered_action ::=
		[  'FOR' 'EACH' {  'ROW' |  'STATEMENT' } ]
		[  'WHEN' left_paren search_condition right_paren ] triggered_SQL_statement

//@@ This definition of triggered  'SQL' statement is superceded by the
//@@ variant from 9075-4 (SQL/PSM).
//@@ Consequently, this one is commented out.
//@@ triggered_SQL_statement ::=
//@@ 		SQL_procedure_statement
//@@ 	| 	'BEGIN'  'ATOMIC' { SQL_procedure_statement semicolon }*   'END'

user-defined_type_definition ::=  'CREATE' 'TYPE' user-defined_type_body

//p
//small
//i user-defined_type_body modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

user-defined_type_body ::=
		user-defined_type_name [ subtype_clause ] [  'AS' representation ]
		[ instantiable_clause ] finality [ reference_type_specification ]
		[ ref_cast_option] [ cast_option ] [ method_specification_list ]

subtype_clause ::=  'UNDER' supertype_name

supertype_name ::= user-defined_type

representation ::= predefined_type | member_list

member_list ::= left_paren member [ { comma member }* ] right_paren

member ::= attribute_definition

attribute_definition ::=
		attribute_name data_type [ reference_scope_check ] [ attribute_default ]
		[ collate_clause ]

attribute_name ::= identifier

attribute_default ::= default_clause

instantiable_clause ::=  'INSTANTIABLE' |  'NOT'  'INSTANTIABLE'

finality ::=  'FINAL' |  'NOT'  'FINAL'

reference_type_specification ::= user-defined_representation | derived_representation | system-generated_representation

user-defined_representation ::=  'REF' 'USING' predefined_type

ref_cast_option ::= [ cast_to_ref ] [ cast_to_type ]

cast_to_ref ::=
	 	'CAST' left_paren  'SOURCE' 'AS'  'REF' right_paren  'WITH' cast_to_ref_identifier

cast_to_ref_identifier ::= identifier

cast_to_type ::=
	 	'CAST' left_paren  'REF' 'AS'  'SOURCE' right_paren  'WITH' cast_to_type_identifier

cast_to_type_identifier ::= identifier

derived_representation ::=  'REF' 'FROM' list_of_attributes

list_of_attributes ::=
		left_paren attribute_name [ { comma attribute_name }*] right_paren

system-generated_representation ::=  'REF' 'IS'  'SYSTEM'  'GENERATED'

cast_option ::= [ cast_to_distinct ] [ cast_to_source ]

cast_to_distinct ::=
	 	'CAST' left_paren  'SOURCE' 'AS'  'DISTINCT' right_paren  'WITH' cast_to_distinct_identifier

cast_to_distinct_identifier ::= identifier

cast_to_source ::=
	 	'CAST' left_paren  'DISTINCT' 'AS'  'SOURCE' right_paren  'WITH' cast_to_source_identifier

cast_to_source_identifier ::= identifier

method_specification_list ::= method_specification [ { comma method_specification }* ]

method_specification ::= original_method_specification | overriding_method_specification

original_method_specification ::=
		partial_method_specification [  'SELF' 'AS'  'RESULT' ] [  'SELF' 'AS'  'LOCATOR' ]
		[ method_characteristics ]

//p
//small
//i partial_method_specification modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

partial_method_specification ::=
		[  'INSTANCE' |  'STATIC' |  'CONSTRUCTOR' ]  'METHOD' method_name
		SQL_parameter_declaration_list returns_clause [  'SPECIFIC' specific_method_name ]

SQL_parameter_declaration_list ::=
		left_paren [ SQL_parameter_declaration
		[ { comma SQL_parameter_declaration }* ] ] right_paren

SQL_parameter_declaration ::=
		[ parameter_mode ] [ SQL_parameter_name ] parameter_type [  'RESULT' ]

parameter_mode ::=  'IN' |  'OUT' |  'INOUT'

SQL_parameter_name ::= identifier

parameter_type ::= data_type [ locator_indication ]

returns_clause ::=  'RETURNS' returns_data_type [ result_cast ]

returns_data_type ::= data_type [ locator_indication ]

result_cast ::=  'CAST' 'FROM' result_cast_from_type

result_cast_from_type ::= data_type [ locator_indication ]

//p
//small
//i specific_method_name added per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

specific_method_name ::= [ schema_name period ] qualified_identifier

method_characteristics ::= method_characteristic*

//p
//small
//i method_characteristic modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

method_characteristic ::=
		language_clause
	|	parameter_style_clause
	|	deterministic_characteristic
	|	SQL-data_access_indication
	|	null-call_clause

parameter_style_clause ::=  'PARAMETER' 'STYLE' parameter_style

parameter_style ::=  'SQL' |  'GENERAL'

deterministic_characteristic ::=  'DETERMINISTIC' |  'NOT'  'DETERMINISTIC'

SQL-data_access_indication ::=
	 	'NO'  'SQL'
	| 	'CONTAINS'  'SQL'
	| 	'READS'  'SQL'  'DATA'
	| 	'MODIFIES'  'SQL'  'DATA'

null-call_clause ::=
	 	'RETURNS'  'NULL' 'ON'  'NULL'  'INPUT'
	| 	'CALLED'  'ON' 'NULL'  'INPUT'

overriding_method_specification ::=  'OVERRIDING' partial_method_specification

schema_routine ::= schema_procedure | schema_function

schema_procedure ::=  'CREATE' SQL-invoked_procedure

SQL-invoked_procedure ::=
	 	'PROCEDURE' schema_qualified_routine_name
		SQL_parameter_declaration_list routine_characteristics routine_body

routine_characteristics ::= [ routine_characteristic* ]

//p
//small
//i routine_characteristic modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

routine_characteristic ::=
		language_clause
	|	parameter_style_clause
	| 	'SPECIFIC' specific_name
	|	deterministic_characteristic
	|	SQL-data_access_indication
	|	null-call_clause
	|	dynamic_result_sets_characteristic

dynamic_result_sets_characteristic ::=
	 	'DYNAMIC'  'RESULT' 'SETS' maximum_dynamic_result_sets

maximum_dynamic_result_sets ::= unsigned_integer

routine_body ::= SQL_routine_body | external_body_reference

SQL_routine_body ::= SQL_procedure_statement

//p
//small
//i external_body_reference modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

external_body_reference ::=
	 	'EXTERNAL' [  'NAME' external_routine_name ] [ parameter_style_clause ]
		[ transform_group_specification ] [ external_security_clause ]

external_routine_name ::= identifier | character_string_literal

external_security_clause ::=
	 	'EXTERNAL'  'SECURITY'  'DEFINER'
	| 	'EXTERNAL'  'SECURITY'  'INVOKER'
	| 	'EXTERNAL'  'SECURITY' 'IMPLEMENTATION'  'DEFINED'

schema_function ::=  'CREATE' SQL-invoked_function

SQL-invoked_function ::=
		{ function_specification | method_specification_designator } routine_body

function_specification ::=
	 	'FUNCTION' schema_qualified_routine_name SQL_parameter_declaration_list
		returns_clause routine_characteristics [ dispatch_clause ]

dispatch_clause ::=  'STATIC'  'DISPATCH'

//p
//small
//i method_specification_designator modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

method_specification_designator ::=
		[  'INSTANCE' |  'STATIC' |  'CONSTRUCTOR' ]  'METHOD' method_name
		SQL_parameter_declaration_list [ returns_clause ]  'FOR' user-defined_type_name

grant_statement ::= grant_privilege_statement | grant_role_statement

grant_privilege_statement ::=
	 	'GRANT' privileges  'TO' grantee [ { comma grantee }* ]
		[  'WITH' 'HIERARCHY'  'OPTION' ] [  'WITH' 'GRANT'  'OPTION' ] [  'GRANTED' 'BY' grantor ]

privileges ::= object_privileges  'ON' object_name

object_privileges ::=  'ALL' 'PRIVILEGES' | action [ { comma action }* ]

action ::=
	 	'SELECT'
	| 	'SELECT' left_paren privilege_column_list right_paren
	| 	'SELECT' left_paren privilege_method_list right_paren
	| 	'DELETE'
	| 	'INSERT' [ left_paren privilege_column_list right_paren ]
	| 	'UPDATE' [ left_paren privilege_column_list right_paren ]
	| 	'REFERENCES' [ left_paren privilege_column_list right_paren ]
	| 	'USAGE'
	| 	'TRIGGER'
	| 	'UNDER'
	| 	'EXECUTE'

privilege_column_list ::= column_name_list

privilege_method_list ::=
		specific_routine_designator [ { comma specific_routine_designator }* ]

object_name ::=
		[  'TABLE' ] table_name
	| 	'DOMAIN' domain_name
	| 	'COLLATION' collation_name
	| 	'CHARACTER'  'SET' character_set_name
	| 	'MODULE' module_name
	| 	'TRANSLATION' translation_name
	| 	'TYPE' user-defined_type_name
	|	specific_routine_designator

grantee ::=  'PUBLIC' | authorization_identifier

grantor ::=  'CURRENT_USER' |  'CURRENT_ROLE'

grant_role_statement ::=
	 	'GRANT' role_granted [ { comma role_granted }* ]  'TO' grantee [ { comma grantee }* ]
		[  'WITH' 'ADMIN'  'OPTION' ] [  'GRANTED' 'BY' grantor ]

role_granted ::= role_name

role_definition ::=  'CREATE' 'ROLE' role_name [  'WITH' 'ADMIN' grantor ]

SQL-invoked_routine ::= schema_routine | module_routine

user-defined_cast_definition ::=
	 	'CREATE'  'CAST' left_paren source_data_type  'AS' target_data_type right_paren
	 	'WITH' cast_function [  'AS' 'ASSIGNMENT' ]

source_data_type ::= data_type

cast_function ::= specific_routine_designator

//p
//small
//i user-defined_ordering_specification modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

user-defined_ordering_definition ::=
	 	'CREATE'  'ORDERING' 'FOR' user-defined_type_name ordering_form

ordering_form ::= equals_ordering_form | full_ordering_form

equals_ordering_form ::=  'EQUALS' 'ONLY'  'BY' ordering_category

ordering_category ::= relative_category | map_category | state_category

relative_category ::=  'RELATIVE' 'WITH' relative_function_specification

relative_function_specification ::= specific_routine_designator

map_category ::=  'MAP' 'WITH' map_function_specification

map_function_specification ::= specific_routine_designator

state_category ::=  'STATE' [ specific_name ]

full_ordering_form ::=  'ORDER' 'FULL'  'BY' ordering_category

//p
//small
//i transform_definition modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

transform_definition ::=
	 	'CREATE' {  'TRANSFORM' |  'TRANSFORMS' }  'FOR' user-defined_type_name
		transform_group*

transform_group ::= group_name left_paren transform_element_list right_paren

transform_element_list ::= transform_element [ comma transform_element ]

transform_element ::= to_sql | from_sql

to_sql ::=  'TO' 'SQL'  'WITH' to_sql_function

to_sql_function ::= specific_routine_designator

from_sql ::=  'FROM' 'SQL'  'WITH' from_sql_function

from_sql_function ::= specific_routine_designator

//hr
//h2  'SQL' Schema Manipulation Statements
///h2

SQL_schema_manipulation_statement ::=
		drop_schema_statement
	|	alter_table_statement
	|	drop_table_statement
	|	drop_view_statement
	|	alter_routine_statement
	|	drop_routine_statement
	|	drop_user-defined_cast_statement
	|	revoke_statement
	|	drop_role_statement
	|	alter_domain_statement
	|	drop_domain_statement
	|	drop_character_set_statement
	|	drop_collation_statement
	|	drop_translation_statement
	|	drop_assertion_statement
	|	drop_trigger_statement
	|	alter_type_statement
	|	drop_data_type_statement
	|	drop_user-defined_ordering_statement
	|	drop_transform_statement
	|	drop_module_statement

drop_schema_statement ::=  'DROP' 'SCHEMA' schema_name drop_behavior

drop_behavior ::=  'CASCADE' |  'RESTRICT'

alter_table_statement ::=  'ALTER' 'TABLE' table_name alter_table_action

alter_table_action ::=
		add_column_definition
	|	alter_column_definition
	|	drop_column_definition
	|	add_table_constraint_definition
	|	drop_table_constraint_definition

add_column_definition ::=  'ADD' [  'COLUMN' ] column_definition

alter_column_definition ::=  'ALTER' [  'COLUMN' ] column_name alter_column_action

alter_column_action ::=
		set_column_default_clause
	|	drop_column_default_clause
	|	add_column_scope_clause
	|	drop_column_scope_clause

set_column_default_clause ::=  'SET' default_clause

drop_column_default_clause ::=  'DROP'  'DEFAULT'

add_column_scope_clause ::=  'ADD' scope_clause

drop_column_scope_clause ::=  'DROP' 'SCOPE' drop_behavior

drop_column_definition ::=  'DROP' [  'COLUMN' ] column_name drop_behavior

add_table_constraint_definition ::=  'ADD' table_constraint_definition

drop_table_constraint_definition ::=  'DROP' 'CONSTRAINT' constraint_name drop_behavior

drop_table_statement ::=  'DROP' 'TABLE' table_name drop_behavior

drop_view_statement ::=  'DROP' 'VIEW' table_name drop_behavior

alter_routine_statement ::=
	 	'ALTER' specific_routine_designator alter_routine_characteristics alter_routine_behaviour

alter_routine_characteristics ::= alter_routine_characteristic*

alter_routine_characteristic ::=
		language_clause
	|	parameter_style_clause
	|	SQL-data_access_indication
	|	null-call_clause
	|	dynamic_result_sets_characteristic
	| 	'NAME' external_routine_name

alter_routine_behaviour ::=  'RESTRICT'

drop_routine_statement ::=  'DROP' specific_routine_designator drop_behavior

drop_user-defined_cast_statement ::=
	 	'DROP'  'CAST' left_paren source_data_type  'AS' target_data_type right_paren
		drop_behavior

revoke_statement ::= revoke_privilege_statement | revoke_role_statement

revoke_privilege_statement ::=
	 	'REVOKE' [ revoke_option_extension ] privileges  'FROM' grantee
		[ { comma grantee }* ] [  'GRANTED' 'BY' grantor ] drop_behavior

revoke_option_extension ::=  'GRANT' 'OPTION'  'FOR' |  'HIERARCHY' 'OPTION'  'FOR'

revoke_role_statement ::=
	 	'REVOKE' [  'ADMIN' 'OPTION'  'FOR' ] role_revoked [ { comma role_revoked }* ]
	 	'FROM' grantee [ { comma grantee }* ] [  'GRANTED' 'BY' grantor ] drop_behavior

role_revoked ::= role_name

drop_role_statement ::=  'DROP' 'ROLE' role_name

alter_domain_statement ::=  'ALTER' 'DOMAIN' domain_name alter_domain_action

alter_domain_action ::=
		set_domain_default_clause
	|	drop_domain_default_clause
	|	add_domain_constraint_definition
	|	drop_domain_constraint_definition

set_domain_default_clause ::=  'SET' default_clause

drop_domain_default_clause ::=  'DROP'  'DEFAULT'

add_domain_constraint_definition ::=  'ADD' domain_constraint

drop_domain_constraint_definition ::=  'DROP' 'CONSTRAINT' constraint_name

drop_domain_statement ::=  'DROP' 'DOMAIN' domain_name drop_behavior

drop_character_set_statement ::=  'DROP' 'CHARACTER'  'SET' character_set_name

drop_collation_statement ::=  'DROP' 'COLLATION' collation_name drop_behavior

drop_translation_statement ::=  'DROP' 'TRANSLATION' translation_name

drop_assertion_statement ::=  'DROP' 'ASSERTION' constraint_name

drop_trigger_statement ::=  'DROP' 'TRIGGER' trigger_name

alter_type_statement ::=  'ALTER' 'TYPE' user-defined_type_name alter_type_action

alter_type_action ::=
		add_attribute_definition
	|	drop_attribute_definition
	|	add_original_method_specification
	|	add_overriding_method_specification
	|	drop_method_specification

add_attribute_definition ::=  'ADD' 'ATTRIBUTE' attribute_definition

drop_attribute_definition ::=  'DROP' 'ATTRIBUTE' attribute_name  'RESTRICT'

add_original_method_specification ::=  'ADD' original_method_specification

add_overriding_method_specification ::=  'ADD' overriding_method_specification

//p
//small
//i drop_method_specification modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

drop_method_specification ::=  'DROP' specific_method_specification_designator  'RESTRICT'

//p
//small
//i specific_method_specification_designator added per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

specific_method_specification_designator ::=
	 	'SPECIFIC'  'METHOD' specific_method_name
	|	[  'INSTANCE' |  'STATIC' |  'CONSTRUCTOR' ]  'METHOD' method_name [ data_type_list ]

drop_data_type_statement ::=  'DROP' 'TYPE' user-defined_type_name drop_behavior

//p
//small
//i drop_user-defined_ordering_statement modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

drop_user-defined_ordering_statement ::=
	 	'DROP'  'ORDERING' 'FOR' user-defined_type_name drop_behavior

//p
//small
//i drop_transform_statement modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

drop_transform_statement ::=
	 	'DROP' {  'TRANSFORM' |  'TRANSFORMS' } transforms_to_be_dropped
	 	'FOR' user-defined_type_name drop_behavior

transforms_to_be_dropped ::=  'ALL' | transform_group_element

transform_group_element ::= group_name

//hr
//h2  'SQL' Data Manipulation Statements
///h2

SQL_data_statement ::=
		open_statement
	|	fetch_statement
	|	close_statement
	|	select_statement_single_row
	|	free_locator_statement
	|	hold_locator_statement
	|	SQL_data_change_statement

open_statement ::=  'OPEN' cursor_name

fetch_statement ::=
	 	'FETCH' [ [ fetch_orientation ]  'FROM' ] cursor_name  'INTO' fetch_target_list

fetch_orientation ::=
	 	'NEXT' |  'PRIOR' |  'FIRST' |  'LAST'
	|	{  'ABSOLUTE' |  'RELATIVE' } simple_value_specification

simple_value_specification ::=
		literal
	|	host_parameter_name
	|	SQL_parameter_reference
	|	SQL_variable_reference
	|	embedded_variable_name

fetch_target_list ::= target_specification [ { comma target_specification }* ]

close_statement ::=  'CLOSE' cursor_name

select_statement_single_row ::=
	 	'SELECT' [ set_quantifier ] select_list  'INTO' select_target_list table_expression

select_target_list ::= target_specification [ { comma target_specification }* ]

free_locator_statement ::=
	 	'FREE'  'LOCATOR' locator_reference [ { comma locator_reference }* ]

locator_reference ::= host_parameter_name | embedded_variable_name

hold_locator_statement ::=
	 	'HOLD'  'LOCATOR' locator_reference [ { comma locator_reference }* ]

SQL_data_change_statement ::=
		delete_statement_positioned
	|	delete_statement_searched
	|	insert_statement
	|	update_statement_positioned
	|	update_statement_searched

delete_statement_positioned ::=
	 	'DELETE'  'FROM' target_table  'WHERE' 'CURRENT'  'OF' cursor_name

//p
//small
//i target_table modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

target_table ::=
		table_name
	|	[  'ONLY' ] left_paren table_name right_paren

delete_statement_searched ::=
	 	'DELETE'  'FROM' target_table [  'WHERE' search_condition ]

insert_statement ::=
	 	'INSERT'  'INTO' insertion_target insert_columns_and_source

insertion_target ::= table_name

insert_columns_and_source ::= from_subquery | from_constructor | from_default

from_subquery ::=
		[ left_paren insert_column_list right_paren ] [ override_clause ] query_expression

insert_column_list ::= column_name_list

from_constructor ::=
		[ left_paren insert_column_list right_paren ] [ override_clause ]
		contextually_typed_table_value_constructor

override_clause ::=  'OVERRIDING' 'USER'  'VALUE' |  'OVERRIDING' 'SYSTEM'  'VALUE'

contextually_typed_table_value_constructor ::=
	 	'VALUES' contextually_typed_row_value_expression_list

contextually_typed_row_value_expression_list ::=
		contextually_typed_row_value_expression
		[ { comma contextually_typed_row_value_expression }* ]

contextually_typed_row_value_expression ::=
		row_value_special_case
	|	contextually_typed_row_value_constructor

contextually_typed_row_value_constructor ::=
		contextually_typed_row_value_constructor_element
	|	[  'ROW' ] left_paren contextually_typed_row_value_constructor_elementlist right_paren

contextually_typed_row_value_constructor_element ::=
		value_expression | contextually_typed_value_specification

contextually_typed_value_specification ::=
		implicitly_typed_value_specification | default_specification

default_specification ::=  'DEFAULT'

contextually_typed_row_value_constructor_elementlist ::=
		contextually_typed_row_value_constructor_element
		[ { comma contextually_typed_row_value_constructor_element }*  ]

from_default ::=  'DEFAULT'  'VALUES'

update_statement_positioned ::=
	 	'UPDATE' target_table  'SET' set_clause_list  'WHERE' 'CURRENT'  'OF' cursor_name

set_clause_list ::= set_clause [ { comma set_clause }* ]

set_clause ::=
		update_target equals_operator update_source
	|	mutated_set_clause equals_operator update_source

//p
//small
//i update_target modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

update_target ::=
		object_column
	|	object_column left_bracket_or_trigraph simple_value_specification right_bracket_or_trigraph

object_column ::= column_name

update_source ::= value_expression | contextually_typed_value_specification

mutated_set_clause ::= mutated_target period method_name

mutated_target ::= object_column | mutated_set_clause

update_statement_searched ::=
	 	'UPDATE' target_table  'SET' set_clause_list [  'WHERE' search_condition ]

//hr
//h2  'SQL' Control Statements
///h2

SQL_control_statement ::=
		call_statement
	|	return_statement
	|	assignment_statement
	|	compound_statement
	|	case_statement
	|	if_statement
	|	iterate_statement
	|	leave_statement
	|	loop_statement
	|	while_statement
	|	repeat_statement
	|	for_statement

call_statement ::=  'CALL' routine_invocation

return_statement ::=  'RETURN' return_value

return_value ::= value_expression |  'NULL'

//hr
//h2 Transaction Management
///h2

SQL_transaction_statement ::=
		start_transaction_statement
	|	set_transaction_statement
	|	set_constraints_mode_statement
	|	savepoint_statement
	|	release_savepoint_statement
	|	commit_statement
	|	rollback_statement

start_transaction_statement ::=
	 	'START'  'TRANSACTION' transaction_mode [ { comma transaction_mode }*]

transaction_mode ::= isolation_level | transaction_access_mode | diagnostics_size

isolation_level ::=  'ISOLATION' 'LEVEL' level_of_isolation

level_of_isolation ::=
	 	'READ'  'UNCOMMITTED'
	| 	'READ'  'COMMITTED'
	| 	'REPEATABLE'  'READ'
	| 	'SERIALIZABLE'

transaction_access_mode ::=  'READ' 'ONLY' |  'READ'  'WRITE'

diagnostics_size ::=  'DIAGNOSTICS' 'SIZE' number_of_conditions

number_of_conditions ::= simple_value_specification

set_transaction_statement ::=  'SET' [  'LOCAL' ] transaction_characteristics

transaction_characteristics ::=
	 	'TRANSACTION' transaction_mode [ { comma transaction_mode }* ]

set_constraints_mode_statement ::=
	 	'SET'  'CONSTRAINTS' constraint_name_list {  'DEFERRED' |  'IMMEDIATE' }

constraint_name_list ::=  'ALL' | constraint_name [ { comma constraint_name }* ]

savepoint_statement ::=  'SAVEPOINT' savepoint_specifier

//p
//small
//i savepoint_specifier modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

savepoint_specifier ::= savepoint_name

savepoint_name ::= identifier

simple_target_specification ::=
		host_parameter_specification
	|	SQL_parameter_reference
	|	column_reference
	|	SQL_variable_reference
	|	embedded_variable_name

release_savepoint_statement ::=  'RELEASE' 'SAVEPOINT' savepoint_specifier

commit_statement ::=  'COMMIT' [  'WORK' ] [  'AND' [  'NO' ]  'CHAIN' ]

rollback_statement ::=  'ROLLBACK' [  'WORK' ] [  'AND' [  'NO' ]   'CHAIN' ] [ savepoint_clause ]

savepoint_clause ::=  'TO' 'SAVEPOINT' savepoint_specifier

//hr
//h2 Connection Management
///h2

SQL_connection_statement ::= connect_statement | set_connection_statement | disconnect_statement

connect_statement ::=  'CONNECT' 'TO' connection_target

connection_target ::=
		SQL-server_name [  'AS' connection_name ] [  'USER' connection_user_name ]
	| 	'DEFAULT'

SQL-server_name ::= simple_value_specification

connection_name ::= simple_value_specification

connection_user_name ::= simple_value_specification

set_connection_statement ::=  'SET' 'CONNECTION' connection_object

connection_object ::=  'DEFAULT' | connection_name

disconnect_statement ::=  'DISCONNECT' disconnect_object

disconnect_object ::= connection_object |  'ALL' |  'CURRENT'

//hr
//h2 Session Attributes
///h2

SQL_session_statement ::=
		set_session_user_identifier_statement
	|	set_role_statement
	|	set_local_time_zone_statement
	|	set_session_characteristics_statement
	|	set_catalog_statement
	|	set_schema_statement
	|	set_names_statement
	|	set_path_statement
	|	set_transform_group_statement

set_session_user_identifier_statement ::=
	 	'SET'  'SESSION' 'AUTHORIZATION' value_specification

set_role_statement ::=  'SET' 'ROLE' role_specification

role_specification ::= value_specification |  'NONE'

set_local_time_zone_statement ::=  'SET' 'TIME'  'ZONE' set_time_zone_value

set_time_zone_value ::= interval_value_expression |  'LOCAL'

set_session_characteristics_statement ::=
	 	'SET'  'SESSION' 'CHARACTERISTICS'  'AS' session_characteristic_list

session_characteristic_list ::= session_characteristic [ { comma session_characteristic }* ]

session_characteristic ::= transaction_characteristics

SQL_diagnostics_statement ::= get_diagnostics_statement | signal_statement | resignal_statement

get_diagnostics_statement ::=  'GET' 'DIAGNOSTICS' SQL_diagnostics_information

SQL_diagnostics_information ::= statement_information | condition_information

statement_information ::=
		statement_information_item [ { comma statement_information_item }* ]

statement_information_item ::=
		simple_target_specification equals_operator statement_information_item_name

statement_information_item_name ::=
	 	'NUMBER'
	| 	'MORE'
	| 	'COMMAND_FUNCTION'
	| 	'COMMAND_FUNCTION_CODE'
	| 	'DYNAMIC_FUNCTION'
	| 	'DYNAMIC_FUNCTION_CODE'
	| 	'ROW_COUNT'
	| 	'TRANSACTIONS_COMMITTED'
	| 	'TRANSACTIONS_ROLLED_BACK'
	| 	'TRANSACTION_ACTIVE'

condition_information ::=
	 	'EXCEPTION' condition_number
		condition_information_item [ { comma condition_information_item }* ]

condition_number ::= simple_value_specification

condition_information_item ::=
		simple_target_specification equals_operator condition_information_item_name

condition_information_item_name ::=
	 	'CATALOG_NAME'
	| 	'CLASS_ORIGIN'
	| 	'COLUMN_NAME'
	| 	'CONDITION_IDENTIFIER'
	| 	'CONDITION_NUMBER'
	| 	'CONNECTION_NAME'
	| 	'CONSTRAINT_CATALOG'
	| 	'CONSTRAINT_NAME'
	| 	'CONSTRAINT_SCHEMA'
	| 	'CURSOR_NAME'
	| 	'MESSAGE_LENGTH'
	| 	'MESSAGE_OCTET_LENGTH'
	| 	'MESSAGE_TEXT'
	| 	'PARAMETER_MODE'
	| 	'PARAMETER_NAME'
	| 	'PARAMETER_ORDINAL_POSITION'
	| 	'RETURNED_SQLSTATE'
	| 	'ROUTINE_CATALOG'
	| 	'ROUTINE_NAME'
	| 	'ROUTINE_SCHEMA'
	| 	'SCHEMA_NAME'
	| 	'SERVER_NAME'
	| 	'SPECIFIC_NAME'
	| 	'SUBCLASS_ORIGIN'
	| 	'TABLE_NAME'
	| 	'TRIGGER_CATALOG'
	| 	'TRIGGER_NAME'
	| 	'TRIGGER_SCHEMA'

dereference_operation ::=
		reference_value_expression dereference_operator attribute_name

method_reference ::=
		value_expression_primary dereference_operator method_name SQL_argument_list

method_selection ::= routine_invocation

//p
//small
//i new_invocation modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

new_invocation ::= method_invocation | routine_invocation

static_method_selection ::= routine_invocation

token ::= nondelimiter_token | delimiter_token

nondelimiter_token ::=
		regular_identifier
	|	key_word
	|	unsigned_numeric_literal
	|	national_character_string_literal
	|	bit_string_literal
	|	hex_string_literal
	|	large_object_length_token
	|	multiplier

key_word ::= reserved_word | non-reserved_word

//p
//small
//i reserved_word modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

reserved_word ::=
		'ABSOLUTE' |  'ACTION' |  'ADD' |  'AFTER' |  'ALL' |  'ALLOCATE' |  'ALTER' |  'AND' |  'ANY' |  'ARE'
	|	'ARRAY' |  'AS' |  'ASC' |  'ASSERTION' |  'AT' |  'AUTHORIZATION'
	|	'BEFORE' |  'BEGIN' |  'BETWEEN' |  'BINARY' |  'BIT' |  'BLOB' |  'BOOLEAN' |  'BOTH'
	|	'BREADTH' |  'BY'
	|	'CALL' |  'CASCADE' |  'CASCADED' |  'CASE' |  'CAST' |  'CATALOG' |  'CHAR' |  'CHARACTER'
	|	'CHECK' |  'CLOB' |  'CLOSE' |  'COLLATE' |  'COLLATION' |  'COLUMN' |  'COMMIT'
	|	'CONDITION' |  'CONNECT' |  'CONNECTION' |  'CONSTRAINT' |  'CONSTRAINTS'
	|	'CONSTRUCTOR' |  'CONTINUE' |  'CORRESPONDING' |  'CREATE' |  'CROSS' |  'CUBE'
	|	'CURRENT' |  'CURRENT_DATE' |  'CURRENT_DEFAULT_TRANSFORM_GROUP'
	|	'CURRENT_TRANSFORM_GROUP_FOR_TYPE' |  'CURRENT_PATH' |  'CURRENT_ROLE'
	|	'CURRENT_TIME' |  'CURRENT_TIMESTAMP' |  'CURRENT_USER' |  'CURSOR' |  'CYCLE'
	|	'DATA' |  'DATE' |  'DAY' |  'DEALLOCATE' |  'DEC' |  'DECIMAL' |  'DECLARE' |  'DEFAULT'
	|	'DEFERRABLE' |  'DEFERRED' |  'DELETE' |  'DEPTH' |  'DEREF' |  'DESC'
	|	'DESCRIBE' |  'DESCRIPTOR' |  'DETERMINISTIC'
	|	'DIAGNOSTICS' |  'DISCONNECT' |  'DISTINCT' |  'DO' |  'DOMAIN' |  'DOUBLE'
	|	'DROP' |  'DYNAMIC'
	|	'EACH' |  'ELSE' |  'ELSEIF' |  'END' | END-EXEC |  'EQUALS' |  'ESCAPE' |  'EXCEPT'
	|	'EXCEPTION' |  'EXEC' |  'EXECUTE' |  'EXISTS' |  'EXIT' |  'EXTERNAL'
	|	'FALSE' |  'FETCH' |  'FIRST' |  'FLOAT' |  'FOR' |  'FOREIGN' |  'FOUND' |  'FROM' |  'FREE'
	|	'FULL' |  'FUNCTION'
	|	'GENERAL' |  'GET' |  'GLOBAL' |  'GO' |  'GOTO' |  'GRANT' |  'GROUP' |  'GROUPING'
	|	'HANDLE' |  'HAVING' |  'HOLD' |  'HOUR'
	|	'IDENTITY' |  'IF' |  'IMMEDIATE' |  'IN' |  'INDICATOR'
	|	'INITIALLY' |  'INNER' |  'INOUT' |  'INPUT' |  'INSERT' |  'INT' |  'INTEGER'
	|	'INTERSECT' |  'INTERVAL' |  'INTO' |  'IS' |  'ISOLATION'
	|	'JOIN'
	|	'KEY'
	|	'LANGUAGE' |  'LARGE' |  'LAST' |  'LATERAL' |  'LEADING' |  'LEAVE' |  'LEFT'
	|	'LEVEL' |  'LIKE' |  'LOCAL' |  'LOCALTIME' |  'LOCALTIMESTAMP' |  'LOCATOR' |  'LOOP'
	|	'MAP' |  'MATCH' |  'METHOD' |  'MINUTE' |  'MODIFIES' |  'MODULE' |  'MONTH'
	|	'NAMES' |  'NATIONAL' |  'NATURAL' |  'NCHAR' |  'NCLOB' |  'NESTING' |  'NEW' |  'NEXT'
	|	'NO' |  'NONE' |  'NOT' |  'NULL' |  'NUMERIC'
	|	'OBJECT' |  'OF' |  'OLD' |  'ON' |  'ONLY' |  'OPEN' |  'OPTION'
	|	'OR' |  'ORDER' |  'ORDINALITY' |  'OUT' |  'OUTER' |  'OUTPUT' |  'OVERLAPS'
	|	'PAD' |  'PARAMETER' |  'PARTIAL' |  'PATH' |  'PRECISION'
	|	'PREPARE' |  'PRESERVE' |  'PRIMARY' |  'PRIOR' |  'PRIVILEGES' |  'PROCEDURE' |  'PUBLIC'
	|	'READ' |  'READS' |  'REAL' |  'RECURSIVE' |  'REDO' |  'REF' |  'REFERENCES' |  'REFERENCING'
	|	'RELATIVE' |  'RELEASE' |  'REPEAT' |  'RESIGNAL' |  'RESTRICT' |  'RESULT' |  'RETURN'
	|	'RETURNS' |  'REVOKE' |  'RIGHT' |  'ROLE' |  'ROLLBACK' |  'ROLLUP' |  'ROUTINE'
	|	'ROW' |  'ROWS'
	|	'SAVEPOINT' |  'SCHEMA' |  'SCROLL' |  'SEARCH' |  'SECOND' |  'SECTION' |  'SELECT'
	|	'SESSION' |  'SESSION_USER' |  'SET' |  'SETS' |  'SIGNAL' |  'SIMILAR' |  'SIZE'
	|	'SMALLINT' |  'SOME' |  'SPACE' |  'SPECIFIC' |  'SPECIFICTYPE' |  'SQL' |  'SQLEXCEPTION'
	|	'SQLSTATE' |  'SQLWARNING' |  'START' |  'STATE' |  'STATIC' |  'SYSTEM_USER'
	|	'TABLE' |  'TEMPORARY' |  'THEN' |  'TIME' |  'TIMESTAMP'
	|	'TIMEZONE_HOUR' |  'TIMEZONE_MINUTE' |  'TO' |  'TRAILING' |  'TRANSACTION'
	|	'TRANSLATION' |  'TREAT' |  'TRIGGER' |  'TRUE'
	|	'UNDER' |  'UNDO' |  'UNION' |  'UNIQUE' |  'UNKNOWN' |  'UNNEST' |  'UNTIL' |  'UPDATE'
	|	'USAGE' |  'USER' |  'USING'
	|	'VALUE' |  'VALUES' |  'VARCHAR' |  'VARYING' |  'VIEW'
	|	'WHEN' |  'WHENEVER' |  'WHERE' |  'WHILE' |  'WITH' |  'WITHOUT' |  'WORK' |  'WRITE'
	|	'YEAR'
	|	'ZONE'

//p
//small
//i non-reserved_word modified per  'ISO' 9075:1999/Cor.1:2000(E)
///i
///small
///p

non-reserved_word ::=
		'ABS' |  'ADA' |  'ADMIN' |  'ASENSITIVE' |  'ASSIGNMENT' |  'ASYMMETRIC' |  'ATOMIC'
	|	'ATTRIBUTE' |  'AVG'
	|	'BIT_LENGTH'
	|	'C' |  'CALLED' |  'CARDINALITY' |  'CATALOG_NAME' |  'CHAIN' |  'CHAR_LENGTH'
	|	'CHARACTERISTICS' |  'CHARACTER_LENGTH' |  'CHARACTER_SET_CATALOG'
	|	'CHARACTER_SET_NAME' |  'CHARACTER_SET_SCHEMA' |  'CHECKED' |  'CLASS_ORIGIN'
	|	'COALESCE' |  'COBOL' |  'COLLATION_CATALOG' |  'COLLATION_NAME' |  'COLLATION_SCHEMA'
	|	'COLUMN_NAME' |  'COMMAND_FUNCTION' |  'COMMAND_FUNCTION_CODE' |  'COMMITTED'
	|	'CONDITION_IDENTIFIER' |  'CONDITION_NUMBER' |  'CONNECTION_NAME'
	|	'CONSTRAINT_CATALOG' |  'CONSTRAINT_NAME' |  'CONSTRAINT_SCHEMA' |  'CONTAINS'
	|	'CONVERT' |  'COUNT' |  'CURSOR_NAME'
	|	'DATETIME_INTERVAL_CODE' |  'DATETIME_INTERVAL_PRECISION' |  'DEFINED'
	|	'DEFINER' |  'DEGREE' |  'DERIVED' |  'DISPATCH'
	|	'EVERY' |  'EXTRACT'
	|	'FINAL' |  'FORTRAN'
	|	'G' |  'GENERATED' |  'GRANTED'
	|	'HIERARCHY'
	|	'IMPLEMENTATION' |  'INSENSITIVE' |  'INSTANCE' |  'INSTANTIABLE' |  'INVOKER'
	|	'K' |  'KEY_MEMBER' |  'KEY_TYPE'
	| 	'LENGTH' |  'LOWER'
	|	'M' |  'MAX' |  'MIN' |  'MESSAGE_LENGTH' |  'MESSAGE_OCTET_LENGTH' |  'MESSAGE_TEXT'
	| 	'MOD' |  'MORE' |  'MUMPS'
	| 	'NAME' |  'NULLABLE' |  'NUMBER' |  'NULLIF'
	| 	'OCTET_LENGTH' |  'ORDERING' |  'OPTIONS' |  'OVERLAY' |  'OVERRIDING'
	| 	'PASCAL' |  'PARAMETER_MODE' |  'PARAMETER_NAME'
	| 	'PARAMETER_ORDINAL_POSITION' |  'PARAMETER_SPECIFIC_CATALOG'
	| 	'PARAMETER_SPECIFIC_NAME' |  'PARAMETER_SPECIFIC_SCHEMA' |  'PLI' |  'POSITION'
	| 	'REPEATABLE' |  'RETURNED_CARDINALITY' |  'RETURNED_LENGTH'
	| 	'RETURNED_OCTET_LENGTH' |  'RETURNED_SQLSTATE' |  'ROUTINE_CATALOG'
	| 	'ROUTINE_NAME' |  'ROUTINE_SCHEMA' |  'ROW_COUNT'
	| 	'SCALE' |  'SCHEMA_NAME' |  'SCOPE' |  'SECURITY' |  'SELF' |  'SENSITIVE' |  'SERIALIZABLE'
	| 	'SERVER_NAME' |  'SIMPLE' |  'SOURCE' |  'SPECIFIC_NAME' |  'STATEMENT' |  'STRUCTURE'
	| 	'STYLE' |  'SUBCLASS_ORIGIN' |  'SUBSTRING' |  'SUM' |  'SYMMETRIC' |  'SYSTEM'
	| 	'TABLE_NAME' |  'TOP_LEVEL_COUNT' |  'TRANSACTIONS_COMMITTED'
	| 	'TRANSACTIONS_ROLLED_BACK' |  'TRANSACTION_ACTIVE' |  'TRANSFORM'
	| 	'TRANSFORMS' |  'TRANSLATE' |  'TRIGGER_CATALOG' |  'TRIGGER_SCHEMA'
	| 	'TRIGGER_NAME' |  'TRIM' |  'TYPE'
	| 	'UNCOMMITTED' |  'UNNAMED' |  'UPPER'

delimiter_token ::=
		character_string_literal
	|	date_string
	|	time_string
	|	timestamp_string
	|	interval_string
	|	delimited_identifier
	|	SQL_special_character
	|	not_equals_operator
	|	greater_than_or_equals_operator
	|	less_than_or_equals_operator
	|	concatenation_operator
	|	right_arrow
	|	left_bracket_trigraph
	|	right_bracket_trigraph
	|	double_colon
	|	double_period

CLI_routine ::= CLI_routine_name CLI_parameter_list [ CLI_returns_clause ]

CLI_routine_name ::= CLI_name_prefixCLI_generic_name

CLI_name_prefix ::= CLI_by-reference_prefix | CLI_by-value_prefix

CLI_by-reference_prefix ::=  'SQLR'

CLI_by-value_prefix ::=  'SQL'

CLI_generic_name ::=
		'AllocConnect' | 'AllocEnv' | 'AllocHandle' | 'AllocStmt'
	|	'BindCol' | 'BindParameter'
	|	'Cancel' | 'CloseCursor' | 'ColAttribute' | 'ColumnPrivileges' | 'Columns' | 'Connect' | 'CopyDesc'
	|	'DataSources' | 'DescribeCol' | 'Disconnect'
	|	'EndTran' | 'Error' | 'ExecDirect' | 'Execute'
	|	'Fetch' | 'FetchScroll' | 'ForeignKeys' | 'FreeConnect' | 'FreeEnv' | 'FreeHandle' | 'FreeStmt'
	|	'GetConnectAttr' | 'GetCursorName' | 'GetData' | 'GetDescField' | 'GetDescRec' | 'GetDiagField'
	|	'GetDiagRec' | 'GetEnvAttr' | 'GetFeatureInfo' | 'GetFunctions' | 'GetInfo' | 'GetLength'
	|	'GetParamData' | 'GetPosition' | 'GetSessionInfo' | 'GetStmtAttr' | 'GetSubString' | 'GetTypeInfo'
	|	'MoreResults'
	|	'NextResult' | 'NumResultCols'
	|	'ParamData' | 'Prepare' | 'PrimaryKeys' | 'PutData'
	|	'RowCount'
	|	'SetConnectAttr' | 'SetCursorName' | 'SetDescField' | 'SetDescRec' | 'SetEnvAttr' | 'SetStmtAttr'
	|	'SpecialColumns' | 'StartTran'
	|	'TablePrivileges' | 'Tables'
	|	implementation-defined_CLI_generic_name

implementation-defined_CLI_generic_name ::= // 'FIXME' !! (See the Syntax Rules)

CLI_parameter_list ::=
		left_paren CLI_parameter_declaration [ { comma CLI_parameter_declaration }* ] right_paren

CLI_parameter_declaration ::=
		CLI_parameter_name CLI_parameter_mode CLI_parameter_data_type

CLI_parameter_name ::= // 'FIXME' !! (See the individual  'CLI' routine definitions)

CLI_parameter_mode ::=  'IN' |  'OUT' |  'DEFIN' |  'DEFOUT' |  'DEF'

CLI_parameter_data_type ::=
	 	'INTEGER'
	| 	'SMALLINT'
	| 	'ANY'
	| 	'CHARACTER' left_paren length right_paren

CLI_returns_clause ::=  'RETURNS'  'SMALLINT'

assignment_statement ::=
	 	'SET' assignment_target equals_operator assignment_source

assignment_target ::= target_specification | modified_field_reference | mutator_reference

SQL_variable_reference ::= basic_identifier_chain

modified_field_reference ::= modified_field_target period field_name

modified_field_target ::=
	target_specification | left_paren target_specification right_paren | modified_field_reference

mutator_reference ::= mutated_target_specification period method_name

mutated_target_specification ::=
		target_specification | left_paren target_specification right_paren | mutator_reference

assignment_source ::= value_expression | contextually_typed_source

contextually_typed_source ::=
		implicitly_typed_value_specification | contextually_typed_row_value_expression

compound_statement ::=
		[ beginning_label colon ]  'BEGIN' [ [  'NOT' ]  'ATOMIC' ]
		[ local_declaration_list ] [ local_cursor_declaration_list ] [ local_handler_declaration_list ]
		[ SQL_statement_list ]  'END' [ ending_label ]

beginning_label ::= statement_label

statement_label ::= identifier

local_declaration_list ::= terminated_local_declaration*

terminated_local_declaration ::= local_declaration semicolon

local_declaration ::= SQL_variable_declaration | condition_declaration

SQL_variable_declaration ::=
	 	'DECLARE' SQL_variable_name_list data_type [ default_clause ]

SQL_variable_name_list ::=
		SQL_variable_name [ { comma SQL_variable_name }* ]

SQL_variable_name ::= identifier

condition_declaration ::=
	 	'DECLARE' condition_name  'CONDITION' [  'FOR' sqlstate_value ]

condition_name ::= identifier

sqlstate_value ::=  'SQLSTATE' [  'VALUE' ] character_string_literal

local_cursor_declaration_list ::= terminated_local_cursor_declaration*

terminated_local_cursor_declaration ::= declare_cursor semicolon

local_handler_declaration_list ::= terminated_local_handler_declaration*

terminated_local_handler_declaration ::= handler_declaration semicolon

handler_declaration ::=
	 	'DECLARE' handler_type  'HANDLER' 'FOR' condition_value_list handler_action

handler_type ::=  'CONTINUE' |  'EXIT' |  'UNDO'

condition_value_list ::= condition_value [ { comma condition_value }* ]

condition_value ::=
		sqlstate_value | condition_name |  'SQLEXCEPTION' |  'SQLWARNING' |  'NOT'  'FOUND'

handler_action ::= SQL_procedure_statement

SQL_statement_list ::= terminated_SQL_statement*

terminated_SQL_statement ::= SQL_procedure_statement semicolon

ending_label ::= statement_label

case_statement ::= simple_case_statement | searched_case_statement

simple_case_statement ::=
	 	'CASE' simple_case_operand_1 simple_case_statement_when_clause*  [ case_statement_else_clause ]  'END'  'CASE'

simple_case_operand_1 ::= value_expression

simple_case_statement_when_clause ::=
	 	'WHEN' simple_case_operand_2  'THEN' SQL_statement_list

simple_case_operand_2 ::= value_expression

case_statement_else_clause ::=  'ELSE' SQL_statement_list

searched_case_statement ::=
	 	'CASE' searched_case_statement_when_clause*  [ case_statement_else_clause ] 'END'  'CASE'

searched_case_statement_when_clause ::=
	 	'WHEN' search_condition  'THEN' SQL_statement_list

if_statement ::=
	 	'IF' search_condition if_statement_then_clause
		[ if_statement_elseif_clause* ] [ if_statement_else_clause ]
	 	'END'  'IF'

if_statement_then_clause ::=  'THEN' SQL_statement_list

if_statement_elseif_clause ::=  'ELSEIF' search_condition  'THEN' SQL_statement_list

if_statement_else_clause ::=  'ELSE' SQL_statement_list

iterate_statement ::=  'ITERATE' statement_label

leave_statement ::=  'LEAVE' statement_label

loop_statement ::=
		[ beginning_label colon ]  'LOOP' SQL_statement_list  'END' 'LOOP' [ ending_label ]

while_statement ::=
		[ beginning_label colon ]  'WHILE' search_condition  'DO' SQL_statement_list  'END' 'WHILE' [ ending_label ]

repeat_statement ::=
		[ beginning_label colon ]  'REPEAT' SQL_statement_list  'UNTIL' search_condition  'END' 'REPEAT' [ ending_label ]

for_statement ::=
		[ beginning_label colon ]  'FOR' for_loop_variable_name  'AS'
		[ cursor_name [ cursor_sensitivity ]  'CURSOR' 'FOR' ] cursor_specification
	 	'DO' SQL_statement_list  'END' 'FOR' [ ending_label ]

for_loop_variable_name ::= identifier

signal_statement ::=  'SIGNAL' signal_value [ set_signal_information ]

signal_value ::= condition_name | sqlstate_value

set_signal_information ::=  'SET' signal_information_item_list

signal_information_item_list ::=
		signal_information_item [ { comma signal_information_item }* ]

signal_information_item ::=
		condition_information_item_name equals_operator simple_value_specification

resignal_statement ::=  'RESIGNAL' [ signal_value ] [ set_signal_information ]

SQL-server_module_definition ::=
	 	'CREATE'  'MODULE' SQL-server_module_name [ SQL-server_module_character_set_specification ]
		[ SQL-server_module_schema_clause ] [ SQL-server_module_path_specification ]
		[ temporary_table_declaration ]
		SQL-server_module_contents*
	 	'END'  'MODULE'

SQL-server_module_name ::= schema_qualified_name

SQL-server_module_character_set_specification ::=  'NAMES' 'ARE' character_set_specification

SQL-server_module_schema_clause ::=  'SCHEMA' default_schema_name

default_schema_name ::= schema_name

SQL-server_module_path_specification ::= path_specification

SQL-server_module_contents ::= SQL-invoked_routine semicolon

module_routine ::= module_procedure | module_function

module_procedure ::= [  'DECLARE' ] SQL-invoked_procedure

module_function ::= [  'DECLARE' ] SQL-invoked_function

drop_module_statement ::=  'DROP' 'MODULE' SQL-server_module_name drop_behavior

//p
//small
//i
//This definition of triggered_SQL_statement is from 9075-4 (SQL/PSM)
//and is documented with:
///i
//NOTE 13 – The preceding production defining triggered_SQL_statement completely supersedes the
//definition in ISO/IEC 9075-2.
///small
///p

triggered_SQL_statement ::= SQL_procedure_statement

//hr
//h2 Dynamic  'SQL'
///h2

//p
//Much, if not all, of the following material comes from ISO/IEC 9075-5:1999, SQL/Bindings.
///p

SQL_dynamic_statement ::=
		system_descriptor_statement
	|	prepare_statement
	|	deallocate_prepared_statement
	|	describe_statement
	|	execute_statement
	|	execute_immediate_statement
	|	SQL_dynamic_data_statement

system_descriptor_statement ::=
		allocate_descriptor_statement
	|	deallocate_descriptor_statement
	|	set_descriptor_statement
	|	get_descriptor_statement

allocate_descriptor_statement ::=
	 	'ALLOCATE' [  'SQL' ]  'DESCRIPTOR' descriptor_name [  'WITH' 'MAX' occurrences ]

descriptor_name ::= [ scope_option ] simple_value_specification

scope_option ::=  'GLOBAL' |  'LOCAL'

embedded_variable_name ::= colonhost_identifier

host_identifier ::=
		Ada_host_identifier
	|	C_host_identifier
	|	COBOL_host_identifier
	|	Fortran_host_identifier
	|	MUMPS_host_identifier
	|	Pascal_host_identifier
	|	PL_I_host_identifier

Ada_host_identifier ::= // 'FIXME' !! (See the Syntax Rules.)
C_host_identifier ::= // 'FIXME' !! (See the Syntax Rules.)
COBOL_host_identifier ::= // 'FIXME' !! (See the Syntax Rules.)
Fortran_host_identifier ::= // 'FIXME' !! (See the Syntax Rules.)
MUMPS_host_identifier ::= // 'FIXME' !! (See the Syntax Rules.)
Pascal_host_identifier ::= // 'FIXME' !! (See the Syntax Rules.)
PL_I_host_identifier ::= // 'FIXME' !! (See the Syntax Rules.)

occurrences ::= simple_value_specification

deallocate_descriptor_statement ::=  'DEALLOCATE' [  'SQL' ]  'DESCRIPTOR' descriptor_name

set_descriptor_statement ::=  'SET' [  'SQL' ]  'DESCRIPTOR' descriptor_name set_descriptor_information

set_descriptor_information ::=
		set_header_information [ { comma set_header_information }* ]
	| 	'VALUE' item_number set_item_information [ { comma set_item_information }* ]

set_header_information ::=
		header_item_name equals_operator simple_value_specification_1

header_item_name ::=
	 	'COUNT' |  'KEY_TYPE' |  'DYNAMIC_FUNCTION' |  'DYNAMIC_FUNCTION_CODE'
	| 	'TOP_LEVEL_COUNT'

simple_value_specification_1 ::= simple_value_specification

item_number ::= simple_value_specification

set_item_information ::=
		descriptor_item_name equals_operator simple_value_specification_2

descriptor_item_name ::=
	 	'CARDINALITY'
	| 	'CHARACTER_SET_CATALOG'
	| 	'CHARACTER_SET_NAME'
	| 	'CHARACTER_SET_SCHEMA'
	| 	'COLLATION_CATALOG'
	| 	'COLLATION_NAME'
	| 	'COLLATION_SCHEMA'
	| 	'DATA'
	| 	'DATETIME_INTERVAL_CODE'
	| 	'DATETIME_INTERVAL_PRECISION'
	| 	'DEGREE'
	| 	'INDICATOR'
	| 	'KEY_MEMBER'
	| 	'LENGTH'
	| 	'LEVEL'
	| 	'NAME'
	| 	'NULLABLE'
	| 	'OCTET_LENGTH'
	| 	'PARAMETER_MODE'
	| 	'PARAMETER_ORDINAL_POSITION'
	| 	'PARAMETER_SPECIFIC_CATALOG'
	| 	'PARAMETER_SPECIFIC_NAME'
	| 	'PARAMETER_SPECIFIC_SCHEMA'
	| 	'PRECISION'
	| 	'RETURNED_CARDINALITY'
	| 	'RETURNED_LENGTH'
	| 	'RETURNED_OCTET_LENGTH'
	| 	'SCALE'
	| 	'SCOPE_CATALOG'
	| 	'SCOPE_NAME'
	| 	'SCOPE_SCHEMA'
	| 	'TYPE'
	| 	'UNNAMED'
	| 	'USER_DEFINED_TYPE_CATALOG'
	| 	'USER_DEFINED_TYPE_NAME'
	| 	'USER_DEFINED_TYPE_SCHEMA'

simple_value_specification_2 ::= simple_value_specification

get_descriptor_statement ::=
	 	'GET' [  'SQL' ]  'DESCRIPTOR' descriptor_name get_descriptor_information

get_descriptor_information ::=
		get_header_information [ { comma get_header_information }* ]
	| 	'VALUE' item_number get_item_information [ { comma get_item_information }* ]

get_header_information ::=
		simple_target_specification_1 equals_operator header_item_name

simple_target_specification_1 ::= simple_target_specification

get_item_information ::=
		simple_target_specification_2 equals_operator descriptor_item_name

simple_target_specification_2 ::= simple_target_specification

prepare_statement ::=
	 	'PREPARE' SQL_statement_name  'FROM' SQL_statement_variable

SQL_statement_name ::=
		statement_name
	|	extended_statement_name

statement_name ::= identifier

extended_statement_name ::= [ scope_option ] simple_value_specification

SQL_statement_variable ::= simple_value_specification

deallocate_prepared_statement ::=  'DEALLOCATE' 'PREPARE' SQL_statement_name

describe_statement ::= describe_input_statement | describe_output_statement

describe_input_statement ::=
	 	'DESCRIBE'  'INPUT' SQL_statement_name using_descriptor [ nesting_option ]

using_descriptor ::=  'USING' [  'SQL' ]  'DESCRIPTOR' descriptor_name

nesting_option ::=  'WITH' 'NESTING' |  'WITHOUT'  'NESTING'

describe_output_statement ::=
	 	'DESCRIBE' [  'OUTPUT' ] described_object using_descriptor [ nesting_option ]

described_object ::=
		SQL_statement_name |  'CURSOR' extended_cursor_name  'STRUCTURE'

extended_cursor_name ::= [ scope_option ] simple_value_specification

execute_statement ::=
	 	'EXECUTE' SQL_statement_name [ result_using_clause ] [ parameter_using_clause ]

result_using_clause ::= output_using_clause

output_using_clause ::= into_arguments | into_descriptor

into_arguments ::=  'INTO' into_argument [ { comma into_argument }* ]

into_argument ::= target_specification

dynamic_parameter_specification ::= question_mark

embedded_variable_specification ::= embedded_variable_name [ indicator_variable ]

indicator_variable ::= [  'INDICATOR' ] embedded_variable_name

into_descriptor ::=  'INTO' [  'SQL' ]  'DESCRIPTOR' descriptor_name

parameter_using_clause ::= input_using_clause

input_using_clause ::= using_arguments | using_input_descriptor

using_arguments ::=  'USING' using_argument [ { comma using_argument }* ]

using_argument ::= general_value_specification

using_input_descriptor ::= using_descriptor

execute_immediate_statement ::=  'EXECUTE' 'IMMEDIATE' SQL_statement_variable

SQL_dynamic_data_statement ::=
		allocate_cursor_statement
	|	dynamic_open_statement
	|	dynamic_fetch_statement
	|	dynamic_close_statement
	|	dynamic_delete_statement_positioned
	|	dynamic_update_statement_positioned

allocate_cursor_statement ::=  'ALLOCATE' extended_cursor_name cursor_intent

cursor_intent ::= statement_cursor | result_set_cursor

statement_cursor ::=
		[ cursor_sensitivity ] [  'SCROLL' ]  'CURSOR' [  'WITH' 'HOLD' ] [  'WITH' 'RETURN' ]
	 	'FOR' extended_statement_name

result_set_cursor ::=
	 	'FOR'  'PROCEDURE' specific_routine_designator

dynamic_open_statement ::=
	 	'OPEN' dynamic_cursor_name [ input_using_clause ]

dynamic_cursor_name ::= cursor_name | extended_cursor_name

dynamic_fetch_statement ::=
	 	'FETCH' [ [ fetch_orientation ]  'FROM' ] dynamic_cursor_name output_using_clause

dynamic_close_statement ::=  'CLOSE' dynamic_cursor_name

dynamic_delete_statement_positioned ::=
	 	'DELETE'  'FROM' target_table  'WHERE' 'CURRENT'  'OF' dynamic_cursor_name

dynamic_update_statement_positioned ::=
	 	'UPDATE' target_table  'SET' set_clause_list  'WHERE' 'CURRENT'  'OF' dynamic_cursor_name

//p
//small
//i
//Note that double_period must be a pair of period characters with no
//intervening space, not a pair of period symbols separated by arbitrary
//white space.
//Normally, the lexical analyzer would return double_period as a symbol.
///i
///small
///p

double_period ::= period period

direct_SQL_statement ::= directly_executable_statement semicolon

directly_executable_statement ::=
		direct_SQL_data_statement
	|	SQL_schema_statement
	|	SQL_transaction_statement
	|	SQL_connection_statement
	|	SQL_session_statement
	|	direct_implementation-defined_statement

direct_SQL_data_statement ::=
		delete_statement_searched
	|	direct_select_statement_multiple_rows
	|	insert_statement
	|	update_statement_searched
	|	temporary_table_declaration

direct_select_statement_multiple_rows ::= query_expression [ order_by_clause ]

set_catalog_statement ::=  'SET' catalog_name_characteristic

catalog_name_characteristic ::=  'CATALOG' value_specification

set_schema_statement ::=  'SET' schema_name_characteristic

schema_name_characteristic ::=  'SCHEMA' value_specification

set_names_statement ::=  'SET' character_set_name_characteristic

character_set_name_characteristic ::=  'NAMES' value_specification

set_path_statement ::=  'SET' SQL-path_characteristic

SQL-path_characteristic ::=  'PATH' value_specification

set_transform_group_statement ::=  'SET' transform_group_characteristic

transform_group_characteristic ::=
	 	'DEFAULT'  'TRANSFORM' 'GROUP' value_specification
	| 	'TRANSFORM'  'GROUP' 'FOR'  'TYPE' user-defined_type value_specification

direct_implementation-defined_statement ::= // 'FIXME' !! (See the Syntax Rules)

embedded_SQL_declare_section ::=
		embedded_SQL_begin_declare
		[ embedded_character_set_declaration ]
		[ host_variable_definition* ]
		embedded_SQL_end_declare
	|	embedded_SQL_MUMPS_declare

embedded_SQL_begin_declare ::=
		SQL_prefix  'BEGIN' 'DECLARE'  'SECTION' [ SQL_terminator ]

SQL_prefix ::=  'EXEC' 'SQL' | ampersandSQLleft_paren

SQL_terminator ::= END-EXEC | semicolon | right_paren

embedded_character_set_declaration ::=
	 	'SQL'  'NAMES' 'ARE' character_set_specification

host_variable_definition ::=
		Ada_variable_definition
	|	C_variable_definition
	|	COBOL_variable_definition
	|	Fortran_variable_definition
	|	MUMPS_variable_definition
	|	Pascal_variable_definition
	|	PL_I_variable_definition

Ada_variable_definition ::=
		Ada_host_identifier [ { comma Ada_host_identifier }* ] colon
		Ada_type_specification [ Ada_initial_value ]

Ada_type_specification ::=
		Ada_qualified_type_specification
	|	Ada_unqualified_type_specification
	|	Ada_derived_type_specification

Ada_qualified_type_specification ::=
		'Interfaces.SQL' period  'CHAR' [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		left_paren 1 double_period length right_paren
	|	'Interfaces.SQL' period  'BIT' left_paren 1 double_period length right_paren
	|	'Interfaces.SQL' period  'SMALLINT'
	|	'Interfaces.SQL' period  'INT'
	|	'Interfaces.SQL' period  'REAL'
	|	'Interfaces.SQL' period  'DOUBLE_PRECISION'
	|	'Interfaces.SQL' period  'BOOLEAN'
	|	'Interfaces.SQL' period  'SQLSTATE_TYPE'
	|	'Interfaces.SQL' period  'INDICATOR_TYPE'

Ada_unqualified_type_specification ::=
	 	'CHAR' left_paren 1 double_period length right_paren
	| 	'BIT' left_paren 1 double_period length right_paren
	| 	'SMALLINT'
	| 	'INT'
	| 	'REAL'
	| 	'DOUBLE_PRECISION'
	| 	'BOOLEAN'
	| 	'SQLSTATE_TYPE'
	| 	'INDICATOR_TYPE'

Ada_derived_type_specification ::=
		Ada_CLOB_variable
	|	Ada_BLOB_variable
	|	Ada_user-defined_type_variable
	|	Ada_CLOB_locator_variable
	|	Ada_BLOB_locator_variable
	|	Ada_user-defined_type_locator_variable
	|	Ada_array_locator_variable
	|	Ada_REF_variable

Ada_CLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]

Ada_BLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' left_paren large_object_length right_paren

Ada_user-defined_type_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type  'AS' predefined_type

Ada_CLOB_locator_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' 'AS'  'LOCATOR'

Ada_BLOB_locator_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' 'AS'  'LOCATOR'

Ada_user-defined_type_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type_name  'AS'  'LOCATOR'

Ada_array_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' collection_type  'AS'  'LOCATOR'

Ada_REF_variable ::=
	 	'SQL'  'TYPE' 'IS' reference_type

Ada_initial_value ::=
		Ada_assignment_operator character_representation*

Ada_assignment_operator ::= colonequals_operator

C_variable_definition ::=
		[ C_storage_class ] [ C_class_modifier ] C_variable_specification semicolon

C_storage_class ::= auto | extern | static

C_class_modifier ::= const | volatile

C_variable_specification ::= C_numeric_variable | C_character_variable | C_derived_variable

C_numeric_variable ::=
		{ long | short | float | double } C_host_identifier [ C_initial_value ]
		[ { comma C_host_identifier [ C_initial_value ] }* ]

C_initial_value ::=
		equals_operator character_representation*

C_character_variable ::=
		C_character_type [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		C_host_identifier C_array_specification [ C_initial_value ]
		[ { comma C_host_identifier C_array_specification [ C_initial_value ] }* ]

C_character_type ::= char | unsigned char | unsigned short

C_array_specification ::= left_bracket length right_bracket

C_derived_variable ::=
		C_VARCHAR_variable
	|	C_NCHAR_variable
	|	C_NCHAR_VARYING_variable
	|	C_CLOB_variable
	|	C_NCLOB_variable
	|	C_BLOB_variable
	|	C_bit_variable
	|	C_user-defined_type_variable
	|	C_CLOB_locator_variable
	|	C_BLOB_locator_variable
	|	C_array_locator_variable
	|	C_user-defined_type_locator_variable
	|	C_REF_variable

C_VARCHAR_variable ::=
	 	'VARCHAR' [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		C_host_identifier C_array_specification [ C_initial_value ]
		[ { comma C_host_identifier C_array_specification [ C_initial_value ] }* ]

C_NCHAR_variable ::=
	 	'NCHAR' [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		C_host_identifier C_array_specification [ C_initial_value ]
		[ { comma C_host_identifier C_array_specification [ C_initial_value ] } * ]

C_NCHAR_VARYING_variable ::=
	 	'NCHAR'  'VARYING' [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		C_host_identifier C_array_specification [ C_initial_value ]
		[ { comma C_host_identifier C_array_specification [ C_initial_value ] } * ]

C_CLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] }* ]

C_NCLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'NCLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] }* ]

C_BLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' left_paren large_object_length right_paren
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] } * ]

C_bit_variable ::=
	 	'BIT' C_host_identifier C_array_specification [ C_initial_value ]
		[ { comma C_host_identifier C_array_specification [ C_initial_value ] }* ]

C_user-defined_type_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type  'AS' predefined_type
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] } * ]

C_CLOB_locator_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' 'AS'  'LOCATOR'
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] } * ]

C_BLOB_locator_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' 'AS'  'LOCATOR'
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] } * ]

C_array_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' collection_type  'AS'  'LOCATOR'
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] } * ]

C_user-defined_type_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type  'AS'  'LOCATOR'
		C_host_identifier [ C_initial_value ] [ { comma C_host_identifier [ C_initial_value ] }* ]

C_REF_variable ::=
	 	'SQL'  'TYPE' 'IS' reference_type

COBOL_variable_definition ::=
		{'01'|'77'} COBOL_host_identifier COBOL_type_specification
		[ character_representation* ] period

COBOL_type_specification ::=
		COBOL_character_type
	|	COBOL_national_character_type
	|	COBOL_bit_type
	|	COBOL_numeric_type
	|	COBOL_integer_type
	|	COBOL_derived_type_specification

COBOL_character_type ::=
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		{  'PIC' |  'PICTURE' } [  'IS' ] { X [ left_paren length right_paren ] }*

COBOL_national_character_type ::=
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
		{  'PIC' |  'PICTURE' } [  'IS' ] { N [ left_paren length right_paren ] }*

COBOL_bit_type ::=
		{  'PIC' |  'PICTURE' } [  'IS' ] { 'X' [ left_paren length right_paren ] }*
	 	'USAGE' [  'IS' ]  'BIT'

COBOL_numeric_type ::=
		{  'PIC' |  'PICTURE' } [  'IS' ] 'S' COBOL_nines_specification
		[  'USAGE' [  'IS' ] ]  'DISPLAY' 'SIGN'  'LEADING'  'SEPARATE'

COBOL_nines_specification ::= COBOL_nines [ 'V' [ COBOL_nines ] ] | 'V' COBOL_nines

COBOL_nines ::= { '9' [ left_paren length right_paren ] }*

COBOL_integer_type ::= COBOL_binary_integer

COBOL_binary_integer ::=
		{  'PIC' |  'PICTURE' } [  'IS' ] SCOBOL_nines [  'USAGE' [  'IS' ] ]  'BINARY'

COBOL_derived_type_specification ::=
		COBOL_CLOB_variable
	|	COBOL_NCLOB_variable
	|	COBOL_BLOB_variable
	|	COBOL_user-defined_type_variable
	|	COBOL_CLOB_locator_variable
	|	COBOL_BLOB_locator_variable
	|	COBOL_array_locator_variable
	|	COBOL_user-defined_type_locator_variable
	|	COBOL_REF_variable

COBOL_CLOB_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' 'CLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]

COBOL_NCLOB_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' 'NCLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]

COBOL_BLOB_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' 'BLOB' left_paren large_object_length right_paren

COBOL_user-defined_type_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' user-defined_type  'AS' predefined_type

COBOL_CLOB_locator_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' 'CLOB'  'AS'  'LOCATOR'

COBOL_BLOB_locator_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' 'BLOB'  'AS'  'LOCATOR'

COBOL_array_locator_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' collection_type  'AS'  'LOCATOR'

COBOL_user-defined_type_locator_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' user-defined_type_name  'AS'  'LOCATOR'

COBOL_REF_variable ::=
		[  'USAGE' [  'IS' ] ]  'SQL' 'TYPE'  'IS' reference_type

Fortran_variable_definition ::=
		Fortran_type_specification Fortran_host_identifier [ { comma Fortran_host_identifier }* ]

//p
//small
//i
//The standard documents 'CHARACTER  'KIND' = n' but there is no explanation
//of the italic 'n' that is used.
//Presumably, it is an integer literal, hence unsigned_integer.
///i
///small
///p

Fortran_type_specification ::=
	 	'CHARACTER' [ asterisk length ] [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
	| 	'CHARACTER'  'KIND' equals_operator unsigned_integer [ asterisk length ] [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
	| 	'BIT' [ asterisk length ]
	| 	'INTEGER'
	| 	'REAL'
	| 	'DOUBLE'  'PRECISION'
	| 	'LOGICAL'
	|	Fortran_derived_type_specification

Fortran_derived_type_specification ::=
		Fortran_CLOB_variable
	|	Fortran_BLOB_variable
	|	Fortran_user-defined_type_variable
	|	Fortran_CLOB_locator_variable
	|	Fortran_BLOB_locator_variable
	|	Fortran_user-defined_type_locator_variable
	|	Fortran_array_locator_variable
	|	Fortran_REF_variable

Fortran_CLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]

Fortran_BLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' left_paren large_object_length right_paren

Fortran_user-defined_type_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type  'AS' predefined_type

Fortran_CLOB_locator_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' 'AS'  'LOCATOR'

Fortran_BLOB_locator_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' 'AS'  'LOCATOR'

Fortran_user-defined_type_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type_name  'AS'  'LOCATOR'

Fortran_array_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' collection_type  'AS'  'LOCATOR'

Fortran_REF_variable ::=
	 	'SQL'  'TYPE' 'IS' reference_type

MUMPS_variable_definition ::=
		MUMPS_numeric_variable semicolon
	|	MUMPS_character_variable semicolon
	|	MUMPS_derived_type_specification semicolon

MUMPS_numeric_variable ::=
		MUMPS_type_specification MUMPS_host_identifier
		[ { comma MUMPS_host_identifier }* ]

MUMPS_type_specification ::=
	 	'INT'
	| 	'DEC' [ left_paren precision [ comma scale ] right_paren ]
	| 	'REAL'

MUMPS_character_variable ::=
	 	'VARCHAR' MUMPS_host_identifier MUMPS_length_specification
		[ { comma MUMPS_host_identifier MUMPS_length_specification }*  ]

MUMPS_length_specification ::=
		left_paren length right_paren

MUMPS_derived_type_specification ::=
		MUMPS_CLOB_variable
	|	MUMPS_BLOB_variable
	|	MUMPS_user-defined_type_variable
	|	MUMPS_CLOB_locator_variable
	|	MUMPS_BLOB_locator_variable
	|	MUMPS_user-defined_type_locator_variable
	|	MUMPS_array_locator_variable
	|	MUMPS_REF_variable

MUMPS_CLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]

MUMPS_BLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' left_paren large_object_length right_paren

MUMPS_user-defined_type_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type  'AS' predefined_type

MUMPS_CLOB_locator_variable ::=  'SQL' 'TYPE'  'IS' 'CLOB'  'AS'  'LOCATOR'

MUMPS_BLOB_locator_variable ::=  'SQL' 'TYPE'  'IS' 'BLOB'  'AS'  'LOCATOR'

MUMPS_user-defined_type_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type_name  'AS'  'LOCATOR'

MUMPS_array_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' collection_type  'AS'  'LOCATOR'

MUMPS_REF_variable ::=  'SQL' 'TYPE'  'IS' reference_type

Pascal_variable_definition ::=
		Pascal_host_identifier [ { comma Pascal_host_identifier }* ] colon
		Pascal_type_specification semicolon

Pascal_type_specification ::=
	 	'PACKED'  'ARRAY' left_bracket 1 double_period length right_bracket
	 	'OF'  'CHAR' [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
	| 	'PACKED'  'ARRAY' left_bracket 1 double_period length right_bracket  'OF'  'BIT'
	| 	'INTEGER'
	| 	'REAL'
	| 	'CHAR' [  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
	| 	'BIT'
	| 	'BOOLEAN'
	|	Pascal_derived_type_specification

Pascal_derived_type_specification ::=
		Pascal_CLOB_variable
	|	Pascal_BLOB_variable
	|	Pascal_user-defined_type_variable
	|	Pascal_CLOB_locator_variable
	|	Pascal_BLOB_locator_variable
	|	Pascal_user-defined_type_locator_variable
	|	Pascal_array_locator_variable
	|	Pascal_REF_variable

Pascal_CLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]

Pascal_BLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' left_paren large_object_length right_paren

Pascal_user-defined_type_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type  'AS' predefined_type

Pascal_CLOB_locator_variable ::=  'SQL' 'TYPE'  'IS' 'CLOB'  'AS'  'LOCATOR'

Pascal_BLOB_locator_variable ::=  'SQL' 'TYPE'  'IS' 'BLOB'  'AS'  'LOCATOR'

Pascal_user-defined_type_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type_name  'AS'  'LOCATOR'

Pascal_array_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' collection_type  'AS'  'LOCATOR'

Pascal_REF_variable ::=  'SQL' 'TYPE'  'IS' reference_type

PL_I_variable_definition ::=
		{DCL |  'DECLARE' }
		{ PL_I_host_identifier | left_paren PL_I_host_identifier [ { comma PL_I_host_identifier }* ] right_paren }
		PL_I_type_specification [ character_representation* ] semicolon

PL_I_type_specification ::=
		{  'CHAR' |  'CHARACTER' } [  'VARYING' ] left_paren length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]
	| 	'BIT' [  'VARYING' ] left_paren length right_paren
	|	PL_I_type_fixed_decimal left_paren precision [ comma scale ] right_paren
	|	PL_I_type_fixed_binary [ left_paren precision right_paren ]
	|	PL_I_type_float_binary left_paren precision right_paren
	|	PL_I_derived_type_specification

PL_I_type_fixed_decimal ::=
		{  'DEC' |  'DECIMAL' }  'FIXED'
	| 	'FIXED' {  'DEC' |  'DECIMAL' }

PL_I_type_fixed_binary ::=
		{  'BIN' |  'BINARY' }  'FIXED'
	| 	'FIXED' {  'BIN' |  'BINARY' }

PL_I_type_float_binary ::=
		{  'BIN' |  'BINARY' }  'FLOAT'
	| 	'FLOAT' {  'BIN' |  'BINARY' }

PL_I_derived_type_specification ::=
		PL_I_CLOB_variable
	|	PL_I_BLOB_variable
	|	PL_I_user-defined_type_variable
	|	PL_I_CLOB_locator_variable
	|	PL_I_BLOB_locator_variable
	|	PL_I_user-defined_type_locator_variable
	|	PL_I_array_locator_variable
	|	PL_I_REF_variable

PL_I_CLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'CLOB' left_paren large_object_length right_paren
		[  'CHARACTER' 'SET' [  'IS' ] character_set_specification ]

PL_I_BLOB_variable ::=
	 	'SQL'  'TYPE' 'IS'  'BLOB' left_paren large_object_length right_paren

PL_I_user-defined_type_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type  'AS' predefined_type

PL_I_CLOB_locator_variable ::=  'SQL' 'TYPE'  'IS' 'CLOB'  'AS'  'LOCATOR'

PL_I_BLOB_locator_variable ::=  'SQL' 'TYPE'  'IS' 'BLOB'  'AS'  'LOCATOR'

PL_I_user-defined_type_locator_variable ::=
	 	'SQL'  'TYPE' 'IS' user-defined_type_name  'AS'  'LOCATOR'

PL_I_array_locator_variable ::=  'SQL' 'TYPE'  'IS' collection_type  'AS'  'LOCATOR'

PL_I_REF_variable ::=  'SQL' 'TYPE'  'IS' reference_type

embedded_SQL_end_declare ::=
		SQL_prefix  'END' 'DECLARE'  'SECTION' [ SQL_terminator ]

embedded_SQL_MUMPS_declare ::=
		SQL_prefix  'BEGIN' 'DECLARE' 'SECTION'
		[ embedded_character_set_declaration ] [ host_variable_definition* ]
	 	'END'  'DECLARE' 'SECTION' SQL_terminator

embedded_SQL_host_program ::=
		embedded_SQL_Ada_program
	|	embedded_SQL_C_program
	|	embedded_SQL_COBOL_program
	|	embedded_SQL_Fortran_program
	|	embedded_SQL_MUMPS_program
	|	embedded_SQL_Pascal_program
	|	embedded_SQL_PL_I_program

embedded_SQL_Ada_program ::= // 'FIXME' !! (See the Syntax Rules.)
embedded_SQL_C_program ::= // 'FIXME' !! (See the Syntax Rules.)
embedded_SQL_COBOL_program ::= // 'FIXME' !! (See the Syntax Rules.)
embedded_SQL_Fortran_program ::= // 'FIXME' !! (See the Syntax Rules.)
embedded_SQL_MUMPS_program ::= // 'FIXME' !! (See the Syntax Rules.)
embedded_SQL_Pascal_program ::= // 'FIXME' !! (See the Syntax Rules.)
embedded_SQL_PL_I_program ::= // 'FIXME' !! (See the Syntax Rules.)
embedded_SQL_statement ::= SQL_prefix statement_or_declaration [ SQL_terminator ]

statement_or_declaration ::=
		declare_cursor
	|	dynamic_declare_cursor
	|	temporary_table_declaration
	|	embedded_authorization_declaration
	|	embedded_path_specification
	|	embedded_transform_group_specification
	|	embedded_exception_declaration
	|	handler_declaration
	|	SQL-invoked_routine
	|	SQL_procedure_statement

dynamic_declare_cursor ::=
	 	'DECLARE' cursor_name [ cursor_sensitivity  ] [ cursor_scrollability ]  'CURSOR'
		[ cursor_holdability ] [ cursor_returnability ]  'FOR' statement_name

embedded_authorization_declaration ::=  'DECLARE' embedded_authorization_clause

embedded_authorization_clause ::=
	 	'SCHEMA' schema_name
	| 	'AUTHORIZATION' embedded_authorization_identifier
		[  'FOR' 'STATIC' {  'ONLY' |  'AND' 'DYNAMIC' } ]
	| 	'SCHEMA' schema_name  'AUTHORIZATION' embedded_authorization_identifier
		[  'FOR' 'STATIC' {  'ONLY' |  'AND' 'DYNAMIC' } ]

embedded_authorization_identifier ::= module_authorization_identifier

embedded_path_specification ::= path_specification

embedded_transform_group_specification ::= transform_group_specification

embedded_exception_declaration ::=  'WHENEVER' condition condition_action

condition ::= SQL_condition

//p
//small
//i
/*The standard documents 'SQLSTATE ( SQLSTATE_class_value [ , <SQLSTATE
subclass value> ] )', but it is not clear why the left_paren, comma
and right_paren are not designated more accurately.*/
///i
///small
///p

SQL_condition ::=
		major_category
	| 	'SQLSTATE' left_paren SQLSTATE_class_value [ comma SQLSTATE_subclass_value ] right_paren
	| 	'CONSTRAINT' constraint_name

major_category ::=  'SQLEXCEPTION' |  'SQLWARNING' |  'NOT'  'FOUND'

SQLSTATE_class_value ::= SQLSTATE_char SQLSTATE_char // 'FIXME' !! (See the Syntax Rules.)

SQLSTATE_char ::= simple_Latin_upper_case_letter | digit

SQLSTATE_subclass_value ::= SQLSTATE_char SQLSTATE_char SQLSTATE_char // 'FIXME' !! (See the Syntax Rules.)

condition_action ::=  'CONTINUE' | go_to

go_to ::= {  'GOTO' |  'GO' 'TO' } goto_target

goto_target ::= host_label_identifier | unsigned_integer | host_PL_I_label_variable

host_label_identifier ::= // 'FIXME' !! (See the Syntax Rules.)

host_PL_I_label_variable ::= // 'FIXME' !! (See the Syntax Rules.)

//p
//small
//i
//This interval primary definition from 9075-5 (SQL/Bindings) is very
//similar to a previous occurrence from 9075-2 (SQL/Foundation), but adds
//the optional interval qualifier.
//The earlier definition is commented out.
///i
///small
///p

interval_primary ::=
		value_expression_primary interval_qualifier?
	|	interval_value_function

//p
//small
//i
/*This module authorization clause definition from 9075-5 (SQL/Bindings)
is similar to a previous occurrence from 9075-2 (SQL/Foundation) but the
optional 'FOR  'STATIC' ONLY' and 'FOR  'STATIC' 'AND' DYNAMIC' clauses were not
present before.
The earlier definition is commented out.*/
///i
///small
///p

module_authorization_clause ::=
	 	'SCHEMA' schema_name
	| 	'AUTHORIZATION' module_authorization_identifier
		[  'FOR' 'STATIC' {  'ONLY' |  'AND' 'DYNAMIC' } ]
	| 	'SCHEMA' schema_name  'AUTHORIZATION' module_authorization_identifier
		[  'FOR' 'STATIC' {  'ONLY' |  'AND' 'DYNAMIC' } ]

preparable_statement ::=
		preparable_SQL_data_statement
	|	preparable_SQL_schema_statement
	|	preparable_SQL_transaction_statement
	|	preparable_SQL_control_statement
	|	preparable_SQL_session_statement
	|	preparable_implementation-defined_statement

preparable_SQL_data_statement ::=
		delete_statement_searched
	|	dynamic_single_row_select_statement
	|	insert_statement
	|	dynamic_select_statement
	|	update_statement_searched
	|	preparable_dynamic_delete_statement_positioned
	|	preparable_dynamic_update_statement_positioned

dynamic_single_row_select_statement ::= query_specification

dynamic_select_statement ::= cursor_specification

preparable_dynamic_delete_statement_positioned ::=
	 	'DELETE' [  'FROM' target_table ]  'WHERE' 'CURRENT'  'OF' [ scope_option ] cursor_name

preparable_dynamic_update_statement_positioned ::=
	 	'UPDATE' [ target_table ]  'SET' set_clause_list  'WHERE' 'CURRENT'  'OF' [ scope_option ] cursor_name

preparable_SQL_schema_statement ::= SQL_schema_statement

preparable_SQL_transaction_statement ::= SQL_transaction_statement

preparable_SQL_control_statement ::= SQL_control_statement

preparable_SQL_session_statement ::= SQL_session_statement

preparable_implementation-defined_statement ::= // 'FIXME' !! (See the Syntax Rules.)

//hr
//h2  'END' 'OF' SQL-99  'GRAMMAR'
///h2

//hr
//h2 Notes on Automatically Converting the SQL-99 Grammar to a  'YACC' Grammar
///h2

//p
/*Automatic translation of this grammar is non-trivial for a number of
reasons.
One is that the grammar has a number of actions '!!
(See the Syntax Rules.)' which cannot be translated automatically.
Another is that the grammar contains rules that are usually better
handled by the lexical analyzer than the grammar proper.
Then there are incomplete rules such as those which reference parts 6
to 10 (they are not defined; indeed, part 7, which was going to be
SQL/Temporal, is in complete abeyance), and the packages (almost
completely undefined in the grammar).
It is not clear whether these can be ignored, or annotated out of the
way.*/
///p

//p
/*Another complication is automatically generating rules to deal with
optional components and repetitive components in the grammar.
Square brackets do not contain alternative non-terminals; all those
expressions are contained within curly brackets within the square
brackets.
However, some square brackets do contain alternative terminals.
Curly brackets contain and group mandatory elements.
However, they are usually used in conjunction with the 'one or more
times' repeater ellipsis '*' mark.
*/
///p

//hr

